{"version":3,"file":"index.js","sources":["../node_modules/uuid/dist/esm-browser/stringify.js","../node_modules/uuid/dist/esm-browser/rng.js","../node_modules/uuid/dist/esm-browser/native.js","../node_modules/uuid/dist/esm-browser/v4.js","../src/types.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random || (options.rng || rng)();\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","export const OSRA_MESSAGE_PROPERTY = '__OSRA__' as const\r\nexport const OSRA_MESSAGE_KEY = '__OSRA_DEFAULT_KEY__' as const\r\nexport const OSRA_PROXY = '__OSRA_PROXY__' as const\r\n\r\nexport type JsonPropertyKey = string | number\r\nexport type JsonCloneType =\r\n  | boolean\r\n  | null\r\n  | number\r\n  | string\r\n  | { [key: string]: JsonCloneType }\r\n  | Array<JsonCloneType>\r\n\r\nexport type StructuredCloneType =\r\n  | JsonCloneType\r\n  | void\r\n  | undefined\r\n  | BigInt\r\n  | Date\r\n  | RegExp\r\n  | Blob\r\n  | File\r\n  | FileList\r\n  | ArrayBuffer\r\n  | ArrayBufferView\r\n  | ImageBitmap\r\n  | ImageData\r\n  | { [key: string]: StructuredCloneType }\r\n  | Array<StructuredCloneType>\r\n  | Map<StructuredCloneType, StructuredCloneType>\r\n  | Set<StructuredCloneType>\r\n\r\nexport type TransferableObject =\r\n  | SharedArrayBuffer\r\n  | ArrayBuffer\r\n  | MessagePort\r\n  | ReadableStream\r\n  | WritableStream\r\n  | TransformStream\r\n  /*\r\n  | ImageBitmap\r\n  | AudioData\r\n  | VideoFrame\r\n  | OffscreenCanvas\r\n  */\r\n\r\nexport type StructuredCloneTransferableType =\r\n  | StructuredCloneType\r\n  | TransferableObject\r\n  | { [key: string]: StructuredCloneTransferableType }\r\n  | Array<StructuredCloneTransferableType>\r\n  | Map<StructuredCloneTransferableType, StructuredCloneTransferableType>\r\n  | Set<StructuredCloneTransferableType>\r\n\r\nexport type ProxiableType =\r\n  | Promise<StructuredCloneTransferableProxiableType>\r\n  | Error\r\n  | MessagePort\r\n  | ReadableStream\r\n  | ((...args: any[]) => Promise<StructuredCloneTransferableProxiableType>)\r\n  // | ((...args: StructuredCloneTransferableProxiableType[]) => StructuredCloneTransferableProxiableType)\r\n  | { [key: string]: StructuredCloneTransferableProxiableType }\r\n  | Array<StructuredCloneTransferableProxiableType>\r\n  | Map<StructuredCloneTransferableProxiableType, StructuredCloneTransferableProxiableType>\r\n  | Set<StructuredCloneTransferableProxiableType>\r\n\r\nexport type StructuredCloneTransferableProxiableType = ProxiableType | StructuredCloneTransferableType\r\n\r\ntype PortOrJsonPort<JsonOnly extends boolean> = JsonOnly extends true ? { portId: string } : { port: MessagePort }\r\ntype StructuredCloneDataOrJsonData<JsonOnly extends boolean> = JsonOnly extends true ? JsonCloneType : StructuredCloneType\r\n\r\nexport type ProxiedFunctionType<JsonOnly extends boolean> = ({ type: 'function' } & PortOrJsonPort<JsonOnly>)\r\nexport type ProxiedMessagePortType<JsonOnly extends boolean> = ({ type: 'messagePort' } & PortOrJsonPort<JsonOnly>)\r\nexport type ProxiedPromiseType<JsonOnly extends boolean> = ({ type: 'promise' } & PortOrJsonPort<JsonOnly>)\r\nexport type ProxiedReadableStreamType<JsonOnly extends boolean> = ({ type: 'readableStream' } & PortOrJsonPort<JsonOnly>)\r\nexport type ProxiedErrorType = ({ type: 'error', message: string, stack?: string })\r\n\r\nexport type ProxiedType<JsonOnly extends boolean> =\r\n  { [OSRA_PROXY]: true } & (\r\n    | ProxiedFunctionType<JsonOnly>\r\n    | ProxiedMessagePortType<JsonOnly>\r\n    | ProxiedPromiseType<JsonOnly>\r\n    | ProxiedReadableStreamType<JsonOnly>\r\n    | ProxiedErrorType\r\n  )\r\nexport type OsraMessage =\r\n  { [OSRA_MESSAGE_PROPERTY]: true, key: string } & (\r\n    | { type: 'ready', envCheck: { buffer: ArrayBuffer, port: MessagePort } }\r\n    | { type: 'init', data: StructuredCloneTransferableType }\r\n    | { type: 'message', portId: string, data: any } // message not needed if transferring MessagePort is supported\r\n    | { type: 'port-closed', portId: string } // message not needed if transferring MessagePort is supported\r\n  )\r\n\r\nexport type RemoteTarget = Window | ServiceWorker | Worker | MessagePort\r\nexport type LocalTarget = WindowEventHandlers | ServiceWorkerContainer | Worker | SharedWorker\r\n","import type {\r\n  StructuredCloneTransferableType, TransferableObject, ProxiedErrorType,\r\n  ProxiedFunctionType, ProxiedMessagePortType, ProxiedPromiseType,\r\n  ProxiedType, StructuredCloneTransferableProxiableType,\r\n} from './types'\r\n\r\nimport { OSRA_PROXY } from './types'\r\n\r\nexport const isClonable = (value: any) =>\r\n  globalThis.SharedArrayBuffer && value instanceof globalThis.SharedArrayBuffer ? true\r\n  : false\r\n\r\nexport const isTransferable = (value: any) =>\r\n  globalThis.ArrayBuffer && value instanceof globalThis.ArrayBuffer ? true\r\n  : globalThis.MessagePort && value instanceof globalThis.MessagePort ? true\r\n  : globalThis.ReadableStream && value instanceof globalThis.ReadableStream ? true\r\n  : globalThis.WritableStream && value instanceof globalThis.WritableStream ? true\r\n  : globalThis.TransformStream && value instanceof globalThis.TransformStream ? true\r\n  : globalThis.ImageBitmap && value instanceof globalThis.ImageBitmap ? true\r\n  : false\r\n\r\nexport const getTransferableObjects = (value: any): TransferableObject[] => {\r\n  const transferables: TransferableObject[] = []\r\n  const recurse = (value: any) => \r\n    isClonable(value) ? undefined\r\n    : isTransferable(value) ? transferables.push(value)\r\n    : Array.isArray(value) ? value.map(recurse)\r\n    : value && typeof value === 'object' ? Object.values(value).map(recurse)\r\n    : undefined\r\n\r\n  recurse(value)\r\n  return transferables\r\n}\r\n\r\nexport type EnvCheck = {\r\n  uuid: string\r\n  supportsPorts: boolean\r\n  jsonOnly: boolean\r\n}\r\n\r\nexport type Context = {\r\n  envCheck: EnvCheck\r\n  addIncomingProxiedMessagePort: (portId: string) => MessagePort\r\n  addOutgoingProxiedMessagePort: (port: MessagePort) => string\r\n  finalizationRegistry: FinalizationRegistry<number>\r\n}\r\n\r\nexport const proxiedFunctionToFunction = <JsonOnly extends boolean>(proxiedFunction: ProxiedFunctionType<JsonOnly>, context: Context) => {\r\n  const portId = 'portId' in proxiedFunction ? proxiedFunction.portId : undefined\r\n  const port =\r\n    'port' in proxiedFunction ? proxiedFunction.port\r\n    : portId ? context.addIncomingProxiedMessagePort(portId)\r\n    : undefined\r\n  if (!port) throw new Error(`No ports received for proxied function`)\r\n\r\n  const func = (...args: StructuredCloneTransferableType[]) =>\r\n    new Promise((resolve, reject) => {\r\n      const { port1: returnValueLocalPort, port2: returnValueRemotePort } = new MessageChannel()\r\n      const functionContext = replaceOutgoingProxiedTypes([returnValueRemotePort, args], context)\r\n      const functionContextTransferables = getTransferableObjects(functionContext)\r\n      const listener = (event: MessageEvent) => {\r\n        const result = replaceIncomingProxiedTypes(event.data, context)\r\n        if (!(result instanceof Promise)) throw new Error(`Proxied function did not return a promise`)\r\n\r\n        result\r\n          .then(resolve)\r\n          .catch(reject)\r\n          .finally(() => returnValueLocalPort.close())\r\n      }\r\n      returnValueLocalPort.addEventListener('message', listener, { once: true })\r\n      returnValueLocalPort.start()\r\n      port.postMessage(functionContext, { transfer: functionContextTransferables })\r\n    })\r\n\r\n  if (portId) {\r\n    context.finalizationRegistry.register(func, Number(portId.split('/')[1]))\r\n  }\r\n\r\n  return func\r\n}\r\n\r\nexport const proxiedMessagePortToMessagePort = <JsonOnly extends boolean>(proxiedMessagePort: ProxiedMessagePortType<JsonOnly>, context: Context) => {\r\n  const port =\r\n    context.envCheck.supportsPorts && 'port' in proxiedMessagePort ? proxiedMessagePort.port\r\n    : 'portId' in proxiedMessagePort ? context.addIncomingProxiedMessagePort(proxiedMessagePort.portId)\r\n    : undefined\r\n  if (!port) throw new Error(`No ports received for proxied message port`)\r\n  return port\r\n}\r\n\r\nexport const proxiedErrorToError = (proxiedError: ProxiedErrorType, context: Context) =>\r\n  new Error(proxiedError.message, { cause: proxiedError.stack })\r\n\r\nexport const proxiedPromiseToPromise = <JsonOnly extends boolean>(proxiedPromise: ProxiedPromiseType<JsonOnly>, context: Context) =>\r\n  new Promise((resolve, reject) => {\r\n    const port =\r\n      'port' in proxiedPromise ? proxiedPromise.port\r\n      : 'portId' in proxiedPromise ? context.addIncomingProxiedMessagePort(proxiedPromise.portId)\r\n      : undefined\r\n    if (!port) throw new Error(`No ports received for proxied promise`)\r\n    const listener = async (event: MessageEvent) => {\r\n      const result = await replaceIncomingProxiedTypes(event.data, context)\r\n      if (result instanceof Error) reject(result)\r\n      else resolve(result)\r\n      port.close()\r\n    }\r\n    port.addEventListener('message', listener, { once: true })\r\n    port.start()\r\n  })\r\n\r\nexport const replaceIncomingProxiedTypes = (value: StructuredCloneTransferableType, context: Context): StructuredCloneTransferableProxiableType =>\r\n  replaceRecursive(\r\n    value,\r\n    (value) => Boolean(\r\n      value && typeof value === 'object' && OSRA_PROXY in value && value[OSRA_PROXY]\r\n    ),\r\n    (proxiedValue: ProxiedType<boolean>) => {\r\n      if (proxiedValue.type === 'function') {\r\n        return proxiedFunctionToFunction(proxiedValue, context)\r\n      } else if (proxiedValue.type === 'error') {\r\n        return proxiedErrorToError(proxiedValue, context)\r\n      } else if (proxiedValue.type === 'messagePort') {\r\n        return proxiedMessagePortToMessagePort(proxiedValue, context)\r\n      } else if (proxiedValue.type === 'promise') {\r\n        return proxiedPromiseToPromise(proxiedValue, context)\r\n      }\r\n      throw new Error(`Unknown incoming proxied type: ${value}`)\r\n    })\r\n\r\nexport const errorToProxiedError = (error: Error, _: Context) => ({\r\n  [OSRA_PROXY]: true,\r\n  type: 'error',\r\n  message: error.message,\r\n  stack: error.stack\r\n})\r\n\r\nexport const messagePortToProxiedMessagePort = (port: MessagePort, context: Context) => ({\r\n  [OSRA_PROXY]: true,\r\n  type: 'messagePort',\r\n  ...context.envCheck.supportsPorts\r\n    ? { port }\r\n    : { portId: context.addOutgoingProxiedMessagePort(port) }\r\n})\r\n\r\nexport const promiseToProxiedPromise = (promise: Promise<StructuredCloneTransferableType>, context: Context) => {\r\n  const { port1: localPort, port2: remotePort } = new MessageChannel()\r\n\r\n  const sendResult = (resultOrError: StructuredCloneTransferableType) => {\r\n    const proxiedResult = replaceOutgoingProxiedTypes(resultOrError, context)\r\n    const transferables = getTransferableObjects(proxiedResult)\r\n    localPort.postMessage(proxiedResult, { transfer: transferables })\r\n    localPort.close()\r\n  }\r\n\r\n  promise\r\n    .then(sendResult)\r\n    .catch(sendResult)\r\n\r\n  return {\r\n    [OSRA_PROXY]: true,\r\n    type: 'promise',\r\n    port: replaceOutgoingProxiedTypes(remotePort, context)\r\n  }\r\n}\r\n\r\nexport const functionToProxiedFunction = (func: Function, context: Context) => {\r\n  const { port1: localPort, port2: remotePort } = new MessageChannel()\r\n  localPort.addEventListener('message', async (ev: MessageEvent<[ProxiedType<boolean>, StructuredCloneTransferableType[]]>) => {\r\n    const [returnValuePort, args] = replaceIncomingProxiedTypes(ev.data, context) as [MessagePort, StructuredCloneTransferableType[]]\r\n    const result = (async () => func(...args))()\r\n    const proxiedResult = replaceOutgoingProxiedTypes(result, context)\r\n    const transferables = getTransferableObjects(proxiedResult)\r\n    returnValuePort.postMessage(proxiedResult, { transfer: transferables })\r\n    returnValuePort.close()\r\n  })\r\n  localPort.start()\r\n  return {\r\n    [OSRA_PROXY]: true,\r\n    type: 'function',\r\n    port: replaceOutgoingProxiedTypes(remotePort, context)\r\n  }\r\n}\r\n\r\nexport const replaceOutgoingProxiedTypes = <T extends StructuredCloneTransferableProxiableType>(value: T, context: Context) =>\r\n  replaceRecursive(\r\n    value,\r\n    (value) => typeof value === 'function' || value instanceof Error || value instanceof MessagePort || value instanceof Promise,\r\n    (value) => {\r\n      if (typeof value === 'function') {\r\n        return functionToProxiedFunction(value, context)\r\n      } else if (value instanceof Error) {\r\n        return errorToProxiedError(value, context)\r\n      } else if (value instanceof MessagePort) {\r\n        return messagePortToProxiedMessagePort(value, context)\r\n      } else if (value instanceof Promise) {\r\n        return promiseToProxiedPromise(value, context)\r\n      }\r\n      throw new Error(`Unknown outgoing proxied type: ${value}`)\r\n    }\r\n  )\r\n\r\nexport const replaceRecursive = <\r\n  T extends StructuredCloneTransferableProxiableType,\r\n  T2 extends (value: any) => any\r\n>(\r\n  value: T,\r\n  shouldReplace: (value: Parameters<T2>[0]) => boolean,\r\n  replaceFunction: T2\r\n) =>\r\n  isClonable(value) ? value\r\n  : isTransferable(value) ? value\r\n  : shouldReplace(value) ? replaceFunction(value)\r\n  : Array.isArray(value) ? value.map(value => replaceRecursive(value, shouldReplace, replaceFunction))\r\n  : value && typeof value === 'object' ? (\r\n    Object.fromEntries(\r\n      Object\r\n        .entries(value)\r\n        .map(([key, value]) => [\r\n          key,\r\n          replaceRecursive(value, shouldReplace, replaceFunction)\r\n        ])\r\n    )\r\n  )\r\n  : value\r\n\r\nexport const makeNumberAllocator = () => {\r\n  let highest = 0\r\n  const freedUnused = new Set<number>()\r\n  return {\r\n    alloc: () => {\r\n      if (freedUnused.size > 0) {\r\n        const number = freedUnused.values().next().value\r\n        if (number === undefined) {\r\n          throw new Error(`Tried to allocate number from freedUnused but result was undefined`)\r\n        }\r\n        freedUnused.delete(number)\r\n        return number\r\n      }\r\n      highest++\r\n      return highest\r\n    },\r\n    free: (number) => {\r\n      freedUnused.add(number)\r\n    }\r\n  }\r\n}\r\n\r\ntype NumberAllocator = ReturnType<typeof makeNumberAllocator>\r\n\r\nexport const makeAllocator = <T>({ numberAllocator }: { numberAllocator: NumberAllocator }) => {\r\n  const channels = new Map<number, T>()\r\n\r\n  const alloc = (value: T) => {\r\n    const id = numberAllocator.alloc()\r\n    channels.set(id, value)\r\n    return id\r\n  }\r\n  const get = (id: number) => channels.get(id)\r\n  const free = (id: number) => {\r\n    channels.delete(id)\r\n    numberAllocator.free(id)\r\n  }\r\n\r\n  return {\r\n    alloc,\r\n    get,\r\n    free\r\n  }\r\n}\r\ntype Allocator<T> = ReturnType<typeof makeAllocator<T>>\r\n","import type { RemoteTarget, StructuredCloneTransferableType, LocalTarget, OsraMessage, StructuredCloneTransferableProxiableType } from './types'\r\nimport type { Context, EnvCheck } from './utils'\r\n\r\nimport { v4 as uuidv4 } from 'uuid'\r\n\r\nimport { OSRA_MESSAGE_KEY, OSRA_MESSAGE_PROPERTY } from './types'\r\nimport { getTransferableObjects, makeAllocator, makeNumberAllocator, replaceIncomingProxiedTypes, replaceOutgoingProxiedTypes } from './utils'\r\n\r\nexport * from './utils'\r\n\r\nexport const expose = async <T extends StructuredCloneTransferableProxiableType>(\r\n  value: StructuredCloneTransferableProxiableType,\r\n  {\r\n    remote: _remote,\r\n    local: _local,\r\n    key = OSRA_MESSAGE_KEY,\r\n    origin = '*'\r\n  }: {\r\n    remote: RemoteTarget | ((osraMessage: OsraMessage, transferables: Transferable[]) => void)\r\n    local: LocalTarget | ((listener: (event: MessageEvent<OsraMessage>) => void) => void)\r\n    key?: string,\r\n    origin?: string\r\n  }\r\n): Promise<T> => {\r\n  const uuid = uuidv4()\r\n\r\n  let envCheck: EnvCheck | undefined\r\n  const finalizationRegistry = new FinalizationRegistry<number>((value) => {\r\n    const allocCallback = allocator.get(value)\r\n    if (!allocCallback) throw new Error(`Osra received a port-closed message with an invalid portId \"${value}\".`)\r\n    allocCallback()\r\n    allocator.free(value)\r\n  })\r\n  const idAllocator = makeNumberAllocator()\r\n  const allocator = makeAllocator<() => void>({ numberAllocator: idAllocator })\r\n  const incomingSerializedPorts = new Map<string, MessagePort>()\r\n\r\n  const addIncomingProxiedMessagePort = (portId: string) => {\r\n    const { port1, port2 } = new MessageChannel()\r\n    incomingSerializedPorts.set(portId, port1)\r\n    return port2\r\n  }\r\n\r\n  const addOutgoingProxiedMessagePort = (port: MessagePort) => {\r\n    const id = allocator.alloc(() => {\r\n      port.close()\r\n    })\r\n    port.addEventListener('message', async (ev) => {\r\n      remote(\r\n        {\r\n          [OSRA_MESSAGE_PROPERTY]: true,\r\n          key,\r\n          type: 'message',\r\n          portId: `${uuid}/${id}`,\r\n          data: replaceOutgoingProxiedTypes(ev.data, getContext())\r\n        },\r\n        []\r\n      )\r\n    })\r\n\r\n    port.addEventListener('close', () => {\r\n      idAllocator.free(id)\r\n      remote(\r\n        {\r\n          [OSRA_MESSAGE_PROPERTY]: true,\r\n          key,\r\n          type: 'port-closed',\r\n          portId: `${uuid}/${id}`\r\n        },\r\n        []\r\n      )\r\n    })\r\n    return `${uuid}/${id}`\r\n  }\r\n\r\n  const getContext = (): Context => {\r\n    if (!envCheck) throw new Error(`Osra context was accessed before the ready message was received.`)\r\n    return {\r\n      addIncomingProxiedMessagePort,\r\n      addOutgoingProxiedMessagePort,\r\n      envCheck,\r\n      finalizationRegistry\r\n    }\r\n  }\r\n\r\n  let resolveRemoteValues, rejectRemoteValues\r\n  const remoteValues = new Promise<T>((res, rej) => {\r\n    resolveRemoteValues = res\r\n    rejectRemoteValues = rej\r\n  })\r\n\r\n  const sendReady = () => {\r\n    const buffer = new ArrayBuffer(1)\r\n    const { port1 } = new MessageChannel()\r\n    remote(\r\n      {\r\n        [OSRA_MESSAGE_PROPERTY]: true,\r\n        key,\r\n        type: 'ready',\r\n        envCheck: { buffer: buffer, port: port1 }\r\n      },\r\n      [buffer, port1]\r\n    )\r\n  }\r\n\r\n  let receivedReady = false\r\n  const listener = async (event: MessageEvent<OsraMessage>) => {\r\n    if (!event.data || typeof event.data !== 'object' || !event.data[OSRA_MESSAGE_PROPERTY] || event.data.key !== key) return\r\n    const { type } = event.data\r\n\r\n    if (type === 'ready' && !receivedReady) {\r\n      receivedReady = true\r\n      envCheck = {\r\n        uuid,\r\n        supportsPorts: event.data.envCheck.port instanceof MessagePort,\r\n        jsonOnly: event.data.envCheck.buffer instanceof ArrayBuffer\r\n      }\r\n      sendReady()\r\n\r\n      const proxiedValue = replaceOutgoingProxiedTypes(value, getContext())\r\n      const transferables = getTransferableObjects(proxiedValue)\r\n      remote(\r\n        {\r\n          [OSRA_MESSAGE_PROPERTY]: true,\r\n          key,\r\n          type: 'init',\r\n          data: proxiedValue\r\n        },\r\n        transferables\r\n      )\r\n      return\r\n    }\r\n\r\n    if (!receivedReady || !envCheck) throw new Error(`Osra received a message before the ready message.`)\r\n\r\n    if (type === 'init') {\r\n      resolveRemoteValues(\r\n        replaceIncomingProxiedTypes(\r\n          event.data.data,\r\n          getContext()\r\n        )\r\n      )\r\n      return\r\n    }\r\n\r\n    if (type === 'message') {\r\n      const { portId, data } = event.data\r\n      const port = incomingSerializedPorts.get(portId)\r\n      if (!port) throw new Error(`Osra received a message with portId set to \"${portId}\" but no port was found.`)\r\n      port.postMessage(data)\r\n    } else if (type === 'port-closed') {\r\n      const { portId } = event.data\r\n      const [messageUuid, _portNumberId] = portId.split('/')\r\n      const messagePortId = Number(_portNumberId)\r\n      if (!messagePortId) throw new Error(`Osra received a port-closed message with an invalid portId \"${portId}\".`)\r\n      if (messageUuid !== uuid && messageUuid !== envCheck.uuid) throw new Error(`Osra received a port-closed message with an invalid portId's uuid \"${portId}\".`)\r\n\r\n      if (messageUuid === uuid) {\r\n        const unregisterCallback = allocator.get(messagePortId)\r\n        if (!unregisterCallback) throw new Error(`Osra received a port-closed message with an invalid portId \"${portId}\".`)\r\n        unregisterCallback()\r\n      } else if (messageUuid === envCheck.uuid) {\r\n        const port = incomingSerializedPorts.get(portId)\r\n        if (!port) throw new Error(`Osra received a message with portId set to \"${portId}\" but no port was found.`)\r\n        port.close()\r\n        incomingSerializedPorts.delete(portId)\r\n      }\r\n    }\r\n  }\r\n\r\n  const remote =\r\n    typeof _remote === 'function' ? _remote\r\n    : (\r\n      (osraMessage: OsraMessage, transferables: Transferable[] = []) =>\r\n        _remote.postMessage(osraMessage, { targetOrigin: origin, transfer: transferables })\r\n    )\r\n\r\n  if (typeof _local === 'function') {\r\n    _local(listener)\r\n  } else {\r\n    _local.addEventListener('message', listener as unknown as EventListener)\r\n  }\r\n\r\n  sendReady()\r\n\r\n  return remoteValues\r\n}\r\n"],"names":["byteToHex","i","unsafeStringify","arr","offset","getRandomValues","rnds8","rng","randomUUID","native","v4","options","buf","rnds","OSRA_MESSAGE_PROPERTY","OSRA_MESSAGE_KEY","OSRA_PROXY","isClonable","value","isTransferable","getTransferableObjects","transferables","recurse","proxiedFunctionToFunction","proxiedFunction","context","portId","port","func","args","resolve","reject","returnValueLocalPort","returnValueRemotePort","functionContext","replaceOutgoingProxiedTypes","functionContextTransferables","listener","event","result","replaceIncomingProxiedTypes","proxiedMessagePortToMessagePort","proxiedMessagePort","proxiedErrorToError","proxiedError","proxiedPromiseToPromise","proxiedPromise","replaceRecursive","proxiedValue","errorToProxiedError","error","_","messagePortToProxiedMessagePort","promiseToProxiedPromise","promise","localPort","remotePort","sendResult","resultOrError","proxiedResult","functionToProxiedFunction","ev","returnValuePort","shouldReplace","replaceFunction","key","makeNumberAllocator","highest","freedUnused","number","makeAllocator","numberAllocator","channels","id","expose","_remote","_local","origin","uuid","uuidv4","envCheck","finalizationRegistry","allocCallback","allocator","idAllocator","incomingSerializedPorts","addIncomingProxiedMessagePort","port1","port2","addOutgoingProxiedMessagePort","remote","getContext","resolveRemoteValues","remoteValues","res","rej","sendReady","buffer","receivedReady","type","data","messageUuid","_portNumberId","messagePortId","unregisterCallback","osraMessage"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}