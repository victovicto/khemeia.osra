var Gt = Object.defineProperty, Rn = Object.getOwnPropertyNames, l = (e, t) => Gt(e, "name", { value: t, configurable: !0 }), Vn = (e, t) => function() {
  return t || (0, e[Rn(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, Xe = (e, t) => {
  for (var n in t)
    Gt(e, n, { get: t[n], enumerable: !0 });
}, Un = Vn({
  "(disabled):util"() {
  }
}), pe = {};
Xe(pe, {
  addChainableMethod: () => ut,
  addLengthGuard: () => fe,
  addMethod: () => it,
  addProperty: () => st,
  checkError: () => _,
  compareByInspect: () => me,
  eql: () => vn,
  expectTypes: () => Ht,
  flag: () => v,
  getActual: () => Se,
  getMessage: () => et,
  getName: () => je,
  getOperator: () => dt,
  getOwnEnumerableProperties: () => ht,
  getOwnEnumerablePropertySymbols: () => lt,
  getPathInfo: () => ot,
  hasProperty: () => Ee,
  inspect: () => S,
  isNaN: () => we,
  isNumeric: () => C,
  isProxyEnabled: () => ue,
  isRegExp: () => ve,
  objDisplay: () => Z,
  overwriteChainableMethod: () => ft,
  overwriteMethod: () => ct,
  overwriteProperty: () => at,
  proxify: () => oe,
  test: () => Le,
  transferFlags: () => V,
  type: () => O
});
var _ = {};
Xe(_, {
  compatibleConstructor: () => Jt,
  compatibleInstance: () => Yt,
  compatibleMessage: () => Zt,
  getConstructorName: () => Qt,
  getMessage: () => Xt
});
function Pe(e) {
  return e instanceof Error || Object.prototype.toString.call(e) === "[object Error]";
}
l(Pe, "isErrorInstance");
function Wt(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
l(Wt, "isRegExp");
function Yt(e, t) {
  return Pe(t) && e === t;
}
l(Yt, "compatibleInstance");
function Jt(e, t) {
  return Pe(t) ? e.constructor === t.constructor || e instanceof t.constructor : (typeof t == "object" || typeof t == "function") && t.prototype ? e.constructor === t || e instanceof t : !1;
}
l(Jt, "compatibleConstructor");
function Zt(e, t) {
  const n = typeof e == "string" ? e : e.message;
  return Wt(t) ? t.test(n) : typeof t == "string" ? n.indexOf(t) !== -1 : !1;
}
l(Zt, "compatibleMessage");
function Qt(e) {
  let t = e;
  return Pe(e) ? t = e.constructor.name : typeof e == "function" && (t = e.name, t === "" && (t = new e().name || t)), t;
}
l(Qt, "getConstructorName");
function Xt(e) {
  let t = "";
  return e && e.message ? t = e.message : typeof e == "string" && (t = e), t;
}
l(Xt, "getMessage");
function v(e, t, n) {
  var r = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    r[t] = n;
  else
    return r[t];
}
l(v, "flag");
function Le(e, t) {
  var n = v(e, "negate"), r = t[0];
  return n ? !r : r;
}
l(Le, "test");
function O(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  const t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
l(O, "type");
var Kn = "captureStackTrace" in Error, E = class Lt extends Error {
  static {
    l(this, "AssertionError");
  }
  message;
  get name() {
    return "AssertionError";
  }
  get ok() {
    return !1;
  }
  constructor(t = "Unspecified AssertionError", n, r) {
    super(t), this.message = t, Kn && Error.captureStackTrace(this, r || Lt);
    for (const o in n)
      o in this || (this[o] = n[o]);
  }
  toJSON(t) {
    return {
      ...this,
      name: this.name,
      message: this.message,
      ok: !1,
      stack: t !== !1 ? this.stack : void 0
    };
  }
};
function Ht(e, t) {
  var n = v(e, "message"), r = v(e, "ssfi");
  n = n ? n + ": " : "", e = v(e, "object"), t = t.map(function(c) {
    return c.toLowerCase();
  }), t.sort();
  var o = t.map(function(c, u) {
    var h = ~["a", "e", "i", "o", "u"].indexOf(c.charAt(0)) ? "an" : "a", p = t.length > 1 && u === t.length - 1 ? "or " : "";
    return p + h + " " + c;
  }).join(", "), a = O(e).toLowerCase();
  if (!t.some(function(c) {
    return a === c;
  }))
    throw new E(
      n + "object tested must be " + o + ", but " + a + " given",
      void 0,
      r
    );
}
l(Ht, "expectTypes");
function Se(e, t) {
  return t.length > 4 ? t[4] : e._obj;
}
l(Se, "getActual");
var _t = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
}, kn = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
}, te = "…";
function en(e, t) {
  const n = _t[kn[t]] || _t[t] || "";
  return n ? `\x1B[${n[0]}m${String(e)}\x1B[${n[1]}m` : String(e);
}
l(en, "colorise");
function tn({
  showHidden: e = !1,
  depth: t = 2,
  colors: n = !1,
  customInspect: r = !0,
  showProxy: o = !1,
  maxArrayLength: a = 1 / 0,
  breakLength: c = 1 / 0,
  seen: u = [],
  // eslint-disable-next-line no-shadow
  truncate: h = 1 / 0,
  stylize: p = String
} = {}, b) {
  const y = {
    showHidden: !!e,
    depth: Number(t),
    colors: !!n,
    customInspect: !!r,
    showProxy: !!o,
    maxArrayLength: Number(a),
    breakLength: Number(c),
    truncate: Number(h),
    seen: u,
    inspect: b,
    stylize: p
  };
  return y.colors && (y.stylize = en), y;
}
l(tn, "normaliseOptions");
function nn(e) {
  return e >= "\uD800" && e <= "\uDBFF";
}
l(nn, "isHighSurrogate");
function G(e, t, n = te) {
  e = String(e);
  const r = n.length, o = e.length;
  if (r > t && o > r)
    return n;
  if (o > t && o > r) {
    let a = t - r;
    return a > 0 && nn(e[a - 1]) && (a = a - 1), `${e.slice(0, a)}${n}`;
  }
  return e;
}
l(G, "truncate");
function z(e, t, n, r = ", ") {
  n = n || t.inspect;
  const o = e.length;
  if (o === 0)
    return "";
  const a = t.truncate;
  let c = "", u = "", h = "";
  for (let p = 0; p < o; p += 1) {
    const b = p + 1 === e.length, y = p + 2 === e.length;
    h = `${te}(${e.length - p})`;
    const x = e[p];
    t.truncate = a - c.length - (b ? 0 : r.length);
    const m = u || n(x, t) + (b ? "" : r), w = c.length + m.length, j = w + h.length;
    if (b && w > a && c.length + h.length <= a || !b && !y && j > a || (u = b ? "" : n(e[p + 1], t) + (y ? "" : r), !b && y && j > a && w + u.length > a))
      break;
    if (c += m, !b && !y && w + u.length >= a) {
      h = `${te}(${e.length - p - 1})`;
      break;
    }
    h = "";
  }
  return `${c}${h}`;
}
l(z, "inspectList");
function rn(e) {
  return e.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? e : JSON.stringify(e).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
l(rn, "quoteComplexKey");
function ne([e, t], n) {
  return n.truncate -= 2, typeof e == "string" ? e = rn(e) : typeof e != "number" && (e = `[${n.inspect(e, n)}]`), n.truncate -= e.length, t = n.inspect(t, n), `${e}: ${t}`;
}
l(ne, "inspectProperty");
function on(e, t) {
  const n = Object.keys(e).slice(e.length);
  if (!e.length && !n.length)
    return "[]";
  t.truncate -= 4;
  const r = z(e, t);
  t.truncate -= r.length;
  let o = "";
  return n.length && (o = z(n.map((a) => [a, e[a]]), t, ne)), `[ ${r}${o ? `, ${o}` : ""} ]`;
}
l(on, "inspectArray");
var Gn = /* @__PURE__ */ l((e) => typeof Buffer == "function" && e instanceof Buffer ? "Buffer" : e[Symbol.toStringTag] ? e[Symbol.toStringTag] : e.constructor.name, "getArrayName");
function K(e, t) {
  const n = Gn(e);
  t.truncate -= n.length + 4;
  const r = Object.keys(e).slice(e.length);
  if (!e.length && !r.length)
    return `${n}[]`;
  let o = "";
  for (let c = 0; c < e.length; c++) {
    const u = `${t.stylize(G(e[c], t.truncate), "number")}${c === e.length - 1 ? "" : ", "}`;
    if (t.truncate -= u.length, e[c] !== e.length && t.truncate <= 3) {
      o += `${te}(${e.length - e[c] + 1})`;
      break;
    }
    o += u;
  }
  let a = "";
  return r.length && (a = z(r.map((c) => [c, e[c]]), t, ne)), `${n}[ ${o}${a ? `, ${a}` : ""} ]`;
}
l(K, "inspectTypedArray");
function sn(e, t) {
  const n = e.toJSON();
  if (n === null)
    return "Invalid Date";
  const r = n.split("T"), o = r[0];
  return t.stylize(`${o}T${G(r[1], t.truncate - o.length - 1)}`, "date");
}
l(sn, "inspectDate");
function ze(e, t) {
  const n = e[Symbol.toStringTag] || "Function", r = e.name;
  return r ? t.stylize(`[${n} ${G(r, t.truncate - 11)}]`, "special") : t.stylize(`[${n}]`, "special");
}
l(ze, "inspectFunction");
function an([e, t], n) {
  return n.truncate -= 4, e = n.inspect(e, n), n.truncate -= e.length, t = n.inspect(t, n), `${e} => ${t}`;
}
l(an, "inspectMapEntry");
function cn(e) {
  const t = [];
  return e.forEach((n, r) => {
    t.push([r, n]);
  }), t;
}
l(cn, "mapToEntries");
function un(e, t) {
  return e.size - 1 <= 0 ? "Map{}" : (t.truncate -= 7, `Map{ ${z(cn(e), t, an)} }`);
}
l(un, "inspectMap");
var Wn = Number.isNaN || ((e) => e !== e);
function Be(e, t) {
  return Wn(e) ? t.stylize("NaN", "number") : e === 1 / 0 ? t.stylize("Infinity", "number") : e === -1 / 0 ? t.stylize("-Infinity", "number") : e === 0 ? t.stylize(1 / e === 1 / 0 ? "+0" : "-0", "number") : t.stylize(G(String(e), t.truncate), "number");
}
l(Be, "inspectNumber");
function Fe(e, t) {
  let n = G(e.toString(), t.truncate - 1);
  return n !== te && (n += "n"), t.stylize(n, "bigint");
}
l(Fe, "inspectBigInt");
function fn(e, t) {
  const n = e.toString().split("/")[2], r = t.truncate - (2 + n.length), o = e.source;
  return t.stylize(`/${G(o, r)}/${n}`, "regexp");
}
l(fn, "inspectRegExp");
function ln(e) {
  const t = [];
  return e.forEach((n) => {
    t.push(n);
  }), t;
}
l(ln, "arrayFromSet");
function hn(e, t) {
  return e.size === 0 ? "Set{}" : (t.truncate -= 7, `Set{ ${z(ln(e), t)} }`);
}
l(hn, "inspectSet");
var qt = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), Yn = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
}, Jn = 16, Zn = 4;
function dn(e) {
  return Yn[e] || `\\u${`0000${e.charCodeAt(0).toString(Jn)}`.slice(-Zn)}`;
}
l(dn, "escape");
function Re(e, t) {
  return qt.test(e) && (e = e.replace(qt, dn)), t.stylize(`'${G(e, t.truncate - 2)}'`, "string");
}
l(Re, "inspectString");
function Ve(e) {
  return "description" in Symbol.prototype ? e.description ? `Symbol(${e.description})` : "Symbol()" : e.toString();
}
l(Ve, "inspectSymbol");
var pn = /* @__PURE__ */ l(() => "Promise{…}", "getPromiseValue");
try {
  const { getPromiseDetails: e, kPending: t, kRejected: n } = process.binding("util");
  Array.isArray(e(Promise.resolve())) && (pn = /* @__PURE__ */ l((r, o) => {
    const [a, c] = e(r);
    return a === t ? "Promise{<pending>}" : `Promise${a === n ? "!" : ""}{${o.inspect(c, o)}}`;
  }, "getPromiseValue"));
} catch {
}
var Qn = pn;
function ae(e, t) {
  const n = Object.getOwnPropertyNames(e), r = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e) : [];
  if (n.length === 0 && r.length === 0)
    return "{}";
  if (t.truncate -= 4, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const o = z(n.map((u) => [u, e[u]]), t, ne), a = z(r.map((u) => [u, e[u]]), t, ne);
  t.seen.pop();
  let c = "";
  return o && a && (c = ", "), `{ ${o}${c}${a} }`;
}
l(ae, "inspectObject");
var $e = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
function gn(e, t) {
  let n = "";
  return $e && $e in e && (n = e[$e]), n = n || e.constructor.name, (!n || n === "_class") && (n = "<Anonymous Class>"), t.truncate -= n.length, `${n}${ae(e, t)}`;
}
l(gn, "inspectClass");
function bn(e, t) {
  return e.length === 0 ? "Arguments[]" : (t.truncate -= 13, `Arguments[ ${z(e, t)} ]`);
}
l(bn, "inspectArguments");
var Xn = [
  "stack",
  "line",
  "column",
  "name",
  "message",
  "fileName",
  "lineNumber",
  "columnNumber",
  "number",
  "description",
  "cause"
];
function yn(e, t) {
  const n = Object.getOwnPropertyNames(e).filter((c) => Xn.indexOf(c) === -1), r = e.name;
  t.truncate -= r.length;
  let o = "";
  if (typeof e.message == "string" ? o = G(e.message, t.truncate) : n.unshift("message"), o = o ? `: ${o}` : "", t.truncate -= o.length + 5, t.seen = t.seen || [], t.seen.includes(e))
    return "[Circular]";
  t.seen.push(e);
  const a = z(n.map((c) => [c, e[c]]), t, ne);
  return `${r}${o}${a ? ` { ${a} }` : ""}`;
}
l(yn, "inspectObject");
function mn([e, t], n) {
  return n.truncate -= 3, t ? `${n.stylize(String(e), "yellow")}=${n.stylize(`"${t}"`, "string")}` : `${n.stylize(String(e), "yellow")}`;
}
l(mn, "inspectAttribute");
function ge(e, t) {
  return z(e, t, He, `
`);
}
l(ge, "inspectHTMLCollection");
function He(e, t) {
  const n = e.getAttributeNames(), r = e.tagName.toLowerCase(), o = t.stylize(`<${r}`, "special"), a = t.stylize(">", "special"), c = t.stylize(`</${r}>`, "special");
  t.truncate -= r.length * 2 + 5;
  let u = "";
  n.length > 0 && (u += " ", u += z(n.map((b) => [b, e.getAttribute(b)]), t, mn, " ")), t.truncate -= u.length;
  const h = t.truncate;
  let p = ge(e.children, t);
  return p && p.length > h && (p = `${te}(${e.children.length})`), `${o}${u}${a}${p}${c}`;
}
l(He, "inspectHTML");
var Ln = typeof Symbol == "function" && typeof Symbol.for == "function", _e = Ln ? Symbol.for("chai/inspect") : "@@chai/inspect", ee = !1;
try {
  const e = Un();
  ee = e.inspect ? e.inspect.custom : !1;
} catch {
  ee = !1;
}
var zt = /* @__PURE__ */ new WeakMap(), Bt = {}, Ft = {
  undefined: (e, t) => t.stylize("undefined", "undefined"),
  null: (e, t) => t.stylize("null", "null"),
  boolean: (e, t) => t.stylize(String(e), "boolean"),
  Boolean: (e, t) => t.stylize(String(e), "boolean"),
  number: Be,
  Number: Be,
  bigint: Fe,
  BigInt: Fe,
  string: Re,
  String: Re,
  function: ze,
  Function: ze,
  symbol: Ve,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: Ve,
  Array: on,
  Date: sn,
  Map: un,
  Set: hn,
  RegExp: fn,
  Promise: Qn,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: (e, t) => t.stylize("WeakSet{…}", "special"),
  WeakMap: (e, t) => t.stylize("WeakMap{…}", "special"),
  Arguments: bn,
  Int8Array: K,
  Uint8Array: K,
  Uint8ClampedArray: K,
  Int16Array: K,
  Uint16Array: K,
  Int32Array: K,
  Uint32Array: K,
  Float32Array: K,
  Float64Array: K,
  Generator: () => "",
  DataView: () => "",
  ArrayBuffer: () => "",
  Error: yn,
  HTMLCollection: ge,
  NodeList: ge
}, Hn = /* @__PURE__ */ l((e, t, n) => _e in e && typeof e[_e] == "function" ? e[_e](t) : ee && ee in e && typeof e[ee] == "function" ? e[ee](t.depth, t) : "inspect" in e && typeof e.inspect == "function" ? e.inspect(t.depth, t) : "constructor" in e && zt.has(e.constructor) ? zt.get(e.constructor)(e, t) : Bt[n] ? Bt[n](e, t) : "", "inspectCustom"), er = Object.prototype.toString;
function be(e, t = {}) {
  const n = tn(t, be), { customInspect: r } = n;
  let o = e === null ? "null" : typeof e;
  if (o === "object" && (o = er.call(e).slice(8, -1)), o in Ft)
    return Ft[o](e, n);
  if (r && e) {
    const c = Hn(e, n, o);
    if (c)
      return typeof c == "string" ? c : be(c, n);
  }
  const a = e ? Object.getPrototypeOf(e) : !1;
  return a === Object.prototype || a === null ? ae(e, n) : e && typeof HTMLElement == "function" && e instanceof HTMLElement ? He(e, n) : "constructor" in e ? e.constructor !== Object ? gn(e, n) : ae(e, n) : e === Object(e) ? ae(e, n) : n.stylize(String(e), o);
}
l(be, "inspect");
var $ = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {boolean}
   * @public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {boolean}
   * @public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {number}
   * @public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {boolean}
   * @public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *         return chai.util.eql(expected, actual, {
   *             comparator: (expected, actual) => {
   *                 // for non number comparison, use the default behavior
   *                 if(typeof expected !== 'number') return null;
   *                 // allow a difference of 10 between compared numbers
   *                 return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *             }
   *         })
   *     };
   *
   * @param {Function}
   * @public
   */
  deepEqual: null
};
function S(e, t, n, r) {
  var o = {
    colors: r,
    depth: typeof n > "u" ? 2 : n,
    showHidden: t,
    truncate: $.truncateThreshold ? $.truncateThreshold : 1 / 0
  };
  return be(e, o);
}
l(S, "inspect");
function Z(e) {
  var t = S(e), n = Object.prototype.toString.call(e);
  if ($.truncateThreshold && t.length >= $.truncateThreshold) {
    if (n === "[object Function]")
      return !e.name || e.name === "" ? "[Function]" : "[Function: " + e.name + "]";
    if (n === "[object Array]")
      return "[ Array(" + e.length + ") ]";
    if (n === "[object Object]") {
      var r = Object.keys(e), o = r.length > 2 ? r.splice(0, 2).join(", ") + ", ..." : r.join(", ");
      return "{ Object (" + o + ") }";
    } else
      return t;
  } else
    return t;
}
l(Z, "objDisplay");
function et(e, t) {
  var n = v(e, "negate"), r = v(e, "object"), o = t[3], a = Se(e, t), c = n ? t[2] : t[1], u = v(e, "message");
  return typeof c == "function" && (c = c()), c = c || "", c = c.replace(/#\{this\}/g, function() {
    return Z(r);
  }).replace(/#\{act\}/g, function() {
    return Z(a);
  }).replace(/#\{exp\}/g, function() {
    return Z(o);
  }), u ? u + ": " + c : c;
}
l(et, "getMessage");
function V(e, t, n) {
  var r = e.__flags || (e.__flags = /* @__PURE__ */ Object.create(null));
  t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null)), n = arguments.length === 3 ? n : !0;
  for (var o in r)
    (n || o !== "object" && o !== "ssfi" && o !== "lockSsfi" && o != "message") && (t.__flags[o] = r[o]);
}
l(V, "transferFlags");
function Ue(e) {
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  const t = e[Symbol.toStringTag];
  return typeof t == "string" ? t : Object.prototype.toString.call(e).slice(8, -1);
}
l(Ue, "type");
function tt() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
l(tt, "FakeMap");
tt.prototype = {
  get: /* @__PURE__ */ l(function(t) {
    return t[this._key];
  }, "get"),
  set: /* @__PURE__ */ l(function(t, n) {
    Object.isExtensible(t) && Object.defineProperty(t, this._key, {
      value: n,
      configurable: !0
    });
  }, "set")
};
var wn = typeof WeakMap == "function" ? WeakMap : tt;
function Ke(e, t, n) {
  if (!n || Q(e) || Q(t))
    return null;
  var r = n.get(e);
  if (r) {
    var o = r.get(t);
    if (typeof o == "boolean")
      return o;
  }
  return null;
}
l(Ke, "memoizeCompare");
function ie(e, t, n, r) {
  if (!(!n || Q(e) || Q(t))) {
    var o = n.get(e);
    o ? o.set(t, r) : (o = new wn(), o.set(t, r), n.set(e, o));
  }
}
l(ie, "memoizeSet");
var vn = ce;
function ce(e, t, n) {
  if (n && n.comparator)
    return ke(e, t, n);
  var r = nt(e, t);
  return r !== null ? r : ke(e, t, n);
}
l(ce, "deepEqual");
function nt(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && // eslint-disable-line no-self-compare
  t !== t ? !0 : Q(e) || Q(t) ? !1 : null;
}
l(nt, "simpleEqual");
function ke(e, t, n) {
  n = n || {}, n.memoize = n.memoize === !1 ? !1 : n.memoize || new wn();
  var r = n && n.comparator, o = Ke(e, t, n.memoize);
  if (o !== null)
    return o;
  var a = Ke(t, e, n.memoize);
  if (a !== null)
    return a;
  if (r) {
    var c = r(e, t);
    if (c === !1 || c === !0)
      return ie(e, t, n.memoize, c), c;
    var u = nt(e, t);
    if (u !== null)
      return u;
  }
  var h = Ue(e);
  if (h !== Ue(t))
    return ie(e, t, n.memoize, !1), !1;
  ie(e, t, n.memoize, !0);
  var p = xn(e, t, h, n);
  return ie(e, t, n.memoize, p), p;
}
l(ke, "extensiveDeepEqual");
function xn(e, t, n, r) {
  switch (n) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return ce(e.valueOf(), t.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return e === t;
    case "Error":
      return rt(e, t, ["name", "message", "code"], r);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return W(e, t, r);
    case "RegExp":
      return Pn(e, t);
    case "Generator":
      return Sn(e, t, r);
    case "DataView":
      return W(new Uint8Array(e.buffer), new Uint8Array(t.buffer), r);
    case "ArrayBuffer":
      return W(new Uint8Array(e), new Uint8Array(t), r);
    case "Set":
      return Ge(e, t, r);
    case "Map":
      return Ge(e, t, r);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return e.equals(t);
    case "Temporal.Duration":
      return e.total("nanoseconds") === t.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return e.toString() === t.toString();
    default:
      return jn(e, t, r);
  }
}
l(xn, "extensiveDeepEqualByType");
function Pn(e, t) {
  return e.toString() === t.toString();
}
l(Pn, "regexpEqual");
function Ge(e, t, n) {
  try {
    if (e.size !== t.size)
      return !1;
    if (e.size === 0)
      return !0;
  } catch {
    return !1;
  }
  var r = [], o = [];
  return e.forEach(/* @__PURE__ */ l(function(c, u) {
    r.push([c, u]);
  }, "gatherEntries")), t.forEach(/* @__PURE__ */ l(function(c, u) {
    o.push([c, u]);
  }, "gatherEntries")), W(r.sort(), o.sort(), n);
}
l(Ge, "entriesEqual");
function W(e, t, n) {
  var r = e.length;
  if (r !== t.length)
    return !1;
  if (r === 0)
    return !0;
  for (var o = -1; ++o < r; )
    if (ce(e[o], t[o], n) === !1)
      return !1;
  return !0;
}
l(W, "iterableEqual");
function Sn(e, t, n) {
  return W(ye(e), ye(t), n);
}
l(Sn, "generatorEqual");
function En(e) {
  return typeof Symbol < "u" && typeof e == "object" && typeof Symbol.iterator < "u" && typeof e[Symbol.iterator] == "function";
}
l(En, "hasIteratorFunction");
function We(e) {
  if (En(e))
    try {
      return ye(e[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
l(We, "getIteratorEntries");
function ye(e) {
  for (var t = e.next(), n = [t.value]; t.done === !1; )
    t = e.next(), n.push(t.value);
  return n;
}
l(ye, "getGeneratorEntries");
function Ye(e) {
  var t = [];
  for (var n in e)
    t.push(n);
  return t;
}
l(Ye, "getEnumerableKeys");
function Je(e) {
  for (var t = [], n = Object.getOwnPropertySymbols(e), r = 0; r < n.length; r += 1) {
    var o = n[r];
    Object.getOwnPropertyDescriptor(e, o).enumerable && t.push(o);
  }
  return t;
}
l(Je, "getEnumerableSymbols");
function rt(e, t, n, r) {
  var o = n.length;
  if (o === 0)
    return !0;
  for (var a = 0; a < o; a += 1)
    if (ce(e[n[a]], t[n[a]], r) === !1)
      return !1;
  return !0;
}
l(rt, "keysEqual");
function jn(e, t, n) {
  var r = Ye(e), o = Ye(t), a = Je(e), c = Je(t);
  if (r = r.concat(a), o = o.concat(c), r.length && r.length === o.length)
    return W(Ze(r).sort(), Ze(o).sort()) === !1 ? !1 : rt(e, t, r, n);
  var u = We(e), h = We(t);
  return u.length && u.length === h.length ? (u.sort(), h.sort(), W(u, h, n)) : r.length === 0 && u.length === 0 && o.length === 0 && h.length === 0;
}
l(jn, "objectEqual");
function Q(e) {
  return e === null || typeof e != "object";
}
l(Q, "isPrimitive");
function Ze(e) {
  return e.map(/* @__PURE__ */ l(function(n) {
    return typeof n == "symbol" ? n.toString() : n;
  }, "mapSymbol"));
}
l(Ze, "mapSymbols");
function Ee(e, t) {
  return typeof e > "u" || e === null ? !1 : t in Object(e);
}
l(Ee, "hasProperty");
function Mn(e) {
  return e.replace(/([^\\])\[/g, "$1.[").match(/(\\\.|[^.]+?)+/g).map((r) => {
    if (r === "constructor" || r === "__proto__" || r === "prototype")
      return {};
    const a = /^\[(\d+)\]$/.exec(r);
    let c = null;
    return a ? c = { i: parseFloat(a[1]) } : c = { p: r.replace(/\\([.[\]])/g, "$1") }, c;
  });
}
l(Mn, "parsePath");
function Qe(e, t, n) {
  let r = e, o = null;
  n = typeof n > "u" ? t.length : n;
  for (let a = 0; a < n; a++) {
    const c = t[a];
    r && (typeof c.p > "u" ? r = r[c.i] : r = r[c.p], a === n - 1 && (o = r));
  }
  return o;
}
l(Qe, "internalGetPathValue");
function ot(e, t) {
  const n = Mn(t), r = n[n.length - 1], o = {
    parent: n.length > 1 ? Qe(e, n, n.length - 1) : e,
    name: r.p || r.i,
    value: Qe(e, n)
  };
  return o.exists = Ee(o.parent, o.name), o;
}
l(ot, "getPathInfo");
function i(e, t, n, r) {
  return v(this, "ssfi", n || i), v(this, "lockSsfi", r), v(this, "object", e), v(this, "message", t), v(this, "eql", $.deepEqual || vn), oe(this);
}
l(i, "Assertion");
Object.defineProperty(i, "includeStack", {
  get: function() {
    return console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), $.includeStack;
  },
  set: function(e) {
    console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), $.includeStack = e;
  }
});
Object.defineProperty(i, "showDiff", {
  get: function() {
    return console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), $.showDiff;
  },
  set: function(e) {
    console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), $.showDiff = e;
  }
});
i.addProperty = function(e, t) {
  st(this.prototype, e, t);
};
i.addMethod = function(e, t) {
  it(this.prototype, e, t);
};
i.addChainableMethod = function(e, t, n) {
  ut(this.prototype, e, t, n);
};
i.overwriteProperty = function(e, t) {
  at(this.prototype, e, t);
};
i.overwriteMethod = function(e, t) {
  ct(this.prototype, e, t);
};
i.overwriteChainableMethod = function(e, t, n) {
  ft(this.prototype, e, t, n);
};
i.prototype.assert = function(e, t, n, r, o, a) {
  var c = Le(this, arguments);
  if (a !== !1 && (a = !0), r === void 0 && o === void 0 && (a = !1), $.showDiff !== !0 && (a = !1), !c) {
    t = et(this, arguments);
    var u = Se(this, arguments), h = {
      actual: u,
      expected: r,
      showDiff: a
    }, p = dt(this, arguments);
    throw p && (h.operator = p), new E(
      t,
      h,
      $.includeStack ? this.assert : v(this, "ssfi")
    );
  }
};
Object.defineProperty(
  i.prototype,
  "_obj",
  {
    get: function() {
      return v(this, "object");
    },
    set: function(e) {
      v(this, "object", e);
    }
  }
);
function ue() {
  return $.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
}
l(ue, "isProxyEnabled");
function st(e, t, n) {
  n = n === void 0 ? function() {
  } : n, Object.defineProperty(
    e,
    t,
    {
      get: /* @__PURE__ */ l(function r() {
        !ue() && !v(this, "lockSsfi") && v(this, "ssfi", r);
        var o = n.call(this);
        if (o !== void 0)
          return o;
        var a = new i();
        return V(this, a), a;
      }, "propertyGetter"),
      configurable: !0
    }
  );
}
l(st, "addProperty");
var tr = Object.getOwnPropertyDescriptor(function() {
}, "length");
function fe(e, t, n) {
  return tr.configurable && Object.defineProperty(e, "length", {
    get: function() {
      throw Error(n ? "Invalid Chai property: " + t + '.length. Due to a compatibility issue, "length" cannot directly follow "' + t + '". Use "' + t + '.lengthOf" instead.' : "Invalid Chai property: " + t + '.length. See docs for proper usage of "' + t + '".');
    }
  }), e;
}
l(fe, "addLengthGuard");
function On(e) {
  var t = Object.getOwnPropertyNames(e);
  function n(o) {
    t.indexOf(o) === -1 && t.push(o);
  }
  l(n, "addProperty");
  for (var r = Object.getPrototypeOf(e); r !== null; )
    Object.getOwnPropertyNames(r).forEach(n), r = Object.getPrototypeOf(r);
  return t;
}
l(On, "getProperties");
var Rt = ["__flags", "__methods", "_obj", "assert"];
function oe(e, t) {
  return ue() ? new Proxy(e, {
    get: /* @__PURE__ */ l(function n(r, o) {
      if (typeof o == "string" && $.proxyExcludedKeys.indexOf(o) === -1 && !Reflect.has(r, o)) {
        if (t)
          throw Error("Invalid Chai property: " + t + "." + o + '. See docs for proper usage of "' + t + '".');
        var a = null, c = 4;
        throw On(r).forEach(function(u) {
          if (!Object.prototype.hasOwnProperty(u) && Rt.indexOf(u) === -1) {
            var h = Nn(
              o,
              u,
              c
            );
            h < c && (a = u, c = h);
          }
        }), Error(a !== null ? "Invalid Chai property: " + o + '. Did you mean "' + a + '"?' : "Invalid Chai property: " + o);
      }
      return Rt.indexOf(o) === -1 && !v(r, "lockSsfi") && v(r, "ssfi", n), Reflect.get(r, o);
    }, "proxyGetter")
  }) : e;
}
l(oe, "proxify");
function Nn(e, t, n) {
  if (Math.abs(e.length - t.length) >= n)
    return n;
  for (var r = [], o = 0; o <= e.length; o++)
    r[o] = Array(t.length + 1).fill(0), r[o][0] = o;
  for (var a = 0; a < t.length; a++)
    r[0][a] = a;
  for (var o = 1; o <= e.length; o++)
    for (var c = e.charCodeAt(o - 1), a = 1; a <= t.length; a++) {
      if (Math.abs(o - a) >= n) {
        r[o][a] = n;
        continue;
      }
      r[o][a] = Math.min(
        r[o - 1][a] + 1,
        r[o][a - 1] + 1,
        r[o - 1][a - 1] + (c === t.charCodeAt(a - 1) ? 0 : 1)
      );
    }
  return r[e.length][t.length];
}
l(Nn, "stringDistanceCapped");
function it(e, t, n) {
  var r = /* @__PURE__ */ l(function() {
    v(this, "lockSsfi") || v(this, "ssfi", r);
    var o = n.apply(this, arguments);
    if (o !== void 0)
      return o;
    var a = new i();
    return V(this, a), a;
  }, "methodWrapper");
  fe(r, t, !1), e[t] = oe(r, t);
}
l(it, "addMethod");
function at(e, t, n) {
  var r = Object.getOwnPropertyDescriptor(e, t), o = /* @__PURE__ */ l(function() {
  }, "_super");
  r && typeof r.get == "function" && (o = r.get), Object.defineProperty(
    e,
    t,
    {
      get: /* @__PURE__ */ l(function a() {
        !ue() && !v(this, "lockSsfi") && v(this, "ssfi", a);
        var c = v(this, "lockSsfi");
        v(this, "lockSsfi", !0);
        var u = n(o).call(this);
        if (v(this, "lockSsfi", c), u !== void 0)
          return u;
        var h = new i();
        return V(this, h), h;
      }, "overwritingPropertyGetter"),
      configurable: !0
    }
  );
}
l(at, "overwriteProperty");
function ct(e, t, n) {
  var r = e[t], o = /* @__PURE__ */ l(function() {
    throw new Error(t + " is not a function");
  }, "_super");
  r && typeof r == "function" && (o = r);
  var a = /* @__PURE__ */ l(function() {
    v(this, "lockSsfi") || v(this, "ssfi", a);
    var c = v(this, "lockSsfi");
    v(this, "lockSsfi", !0);
    var u = n(o).apply(this, arguments);
    if (v(this, "lockSsfi", c), u !== void 0)
      return u;
    var h = new i();
    return V(this, h), h;
  }, "overwritingMethodWrapper");
  fe(a, t, !1), e[t] = oe(a, t);
}
l(ct, "overwriteMethod");
var nr = typeof Object.setPrototypeOf == "function", Vt = /* @__PURE__ */ l(function() {
}, "testFn"), rr = Object.getOwnPropertyNames(Vt).filter(function(e) {
  var t = Object.getOwnPropertyDescriptor(Vt, e);
  return typeof t != "object" ? !0 : !t.configurable;
}), or = Function.prototype.call, sr = Function.prototype.apply;
function ut(e, t, n, r) {
  typeof r != "function" && (r = /* @__PURE__ */ l(function() {
  }, "chainingBehavior"));
  var o = {
    method: n,
    chainingBehavior: r
  };
  e.__methods || (e.__methods = {}), e.__methods[t] = o, Object.defineProperty(
    e,
    t,
    {
      get: /* @__PURE__ */ l(function() {
        o.chainingBehavior.call(this);
        var c = /* @__PURE__ */ l(function() {
          v(this, "lockSsfi") || v(this, "ssfi", c);
          var p = o.method.apply(this, arguments);
          if (p !== void 0)
            return p;
          var b = new i();
          return V(this, b), b;
        }, "chainableMethodWrapper");
        if (fe(c, t, !0), nr) {
          var u = Object.create(this);
          u.call = or, u.apply = sr, Object.setPrototypeOf(c, u);
        } else {
          var h = Object.getOwnPropertyNames(e);
          h.forEach(function(p) {
            if (rr.indexOf(p) === -1) {
              var b = Object.getOwnPropertyDescriptor(e, p);
              Object.defineProperty(c, p, b);
            }
          });
        }
        return V(this, c), oe(c);
      }, "chainableMethodGetter"),
      configurable: !0
    }
  );
}
l(ut, "addChainableMethod");
function ft(e, t, n, r) {
  var o = e.__methods[t], a = o.chainingBehavior;
  o.chainingBehavior = /* @__PURE__ */ l(function() {
    var h = r(a).call(this);
    if (h !== void 0)
      return h;
    var p = new i();
    return V(this, p), p;
  }, "overwritingChainableMethodGetter");
  var c = o.method;
  o.method = /* @__PURE__ */ l(function() {
    var h = n(c).apply(this, arguments);
    if (h !== void 0)
      return h;
    var p = new i();
    return V(this, p), p;
  }, "overwritingChainableMethodWrapper");
}
l(ft, "overwriteChainableMethod");
function me(e, t) {
  return S(e) < S(t) ? -1 : 1;
}
l(me, "compareByInspect");
function lt(e) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(e).filter(function(t) {
    return Object.getOwnPropertyDescriptor(e, t).enumerable;
  });
}
l(lt, "getOwnEnumerablePropertySymbols");
function ht(e) {
  return Object.keys(e).concat(lt(e));
}
l(ht, "getOwnEnumerableProperties");
function An(e) {
  return e !== e;
}
l(An, "_isNaN");
var we = Number.isNaN || An;
function Tn(e) {
  var t = O(e), n = ["Array", "Object", "Function"];
  return n.indexOf(t) !== -1;
}
l(Tn, "isObjectType");
function dt(e, t) {
  var n = v(e, "operator"), r = v(e, "negate"), o = t[3], a = r ? t[2] : t[1];
  if (n)
    return n;
  if (typeof a == "function" && (a = a()), a = a || "", !!a && !/\shave\s/.test(a)) {
    var c = Tn(o);
    return /\snot\s/.test(a) ? c ? "notDeepStrictEqual" : "notStrictEqual" : c ? "deepStrictEqual" : "strictEqual";
  }
}
l(dt, "getOperator");
function je(e) {
  return e.name;
}
l(je, "getName");
function ve(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
l(ve, "isRegExp");
function C(e) {
  return ["Number", "BigInt"].includes(O(e));
}
l(C, "isNumeric");
var { flag: f } = pe;
[
  "to",
  "be",
  "been",
  "is",
  "and",
  "has",
  "have",
  "with",
  "that",
  "which",
  "at",
  "of",
  "same",
  "but",
  "does",
  "still",
  "also"
].forEach(function(e) {
  i.addProperty(e);
});
i.addProperty("not", function() {
  f(this, "negate", !0);
});
i.addProperty("deep", function() {
  f(this, "deep", !0);
});
i.addProperty("nested", function() {
  f(this, "nested", !0);
});
i.addProperty("own", function() {
  f(this, "own", !0);
});
i.addProperty("ordered", function() {
  f(this, "ordered", !0);
});
i.addProperty("any", function() {
  f(this, "any", !0), f(this, "all", !1);
});
i.addProperty("all", function() {
  f(this, "all", !0), f(this, "any", !1);
});
var Ut = {
  function: ["function", "asyncfunction", "generatorfunction", "asyncgeneratorfunction"],
  asyncfunction: ["asyncfunction", "asyncgeneratorfunction"],
  generatorfunction: ["generatorfunction", "asyncgeneratorfunction"],
  asyncgeneratorfunction: ["asyncgeneratorfunction"]
};
function pt(e, t) {
  t && f(this, "message", t), e = e.toLowerCase();
  var n = f(this, "object"), r = ~["a", "e", "i", "o", "u"].indexOf(e.charAt(0)) ? "an " : "a ";
  const o = O(n).toLowerCase();
  Ut.function.includes(e) ? this.assert(
    Ut[e].includes(o),
    "expected #{this} to be " + r + e,
    "expected #{this} not to be " + r + e
  ) : this.assert(
    e === o,
    "expected #{this} to be " + r + e,
    "expected #{this} not to be " + r + e
  );
}
l(pt, "an");
i.addChainableMethod("an", pt);
i.addChainableMethod("a", pt);
function In(e, t) {
  return we(e) && we(t) || e === t;
}
l(In, "SameValueZero");
function le() {
  f(this, "contains", !0);
}
l(le, "includeChainingBehavior");
function he(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = O(n).toLowerCase(), o = f(this, "message"), a = f(this, "negate"), c = f(this, "ssfi"), u = f(this, "deep"), h = u ? "deep " : "", p = u ? f(this, "eql") : In;
  o = o ? o + ": " : "";
  var b = !1;
  switch (r) {
    case "string":
      b = n.indexOf(e) !== -1;
      break;
    case "weakset":
      if (u)
        throw new E(
          o + "unable to use .deep.include with WeakSet",
          void 0,
          c
        );
      b = n.has(e);
      break;
    case "map":
      n.forEach(function(w) {
        b = b || p(w, e);
      });
      break;
    case "set":
      u ? n.forEach(function(w) {
        b = b || p(w, e);
      }) : b = n.has(e);
      break;
    case "array":
      u ? b = n.some(function(w) {
        return p(w, e);
      }) : b = n.indexOf(e) !== -1;
      break;
    default:
      if (e !== Object(e))
        throw new E(
          o + "the given combination of arguments (" + r + " and " + O(e).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + O(e).toLowerCase(),
          void 0,
          c
        );
      var y = Object.keys(e), x = null, m = 0;
      if (y.forEach(function(w) {
        var j = new i(n);
        if (V(this, j, !0), f(j, "lockSsfi", !0), !a || y.length === 1) {
          j.property(w, e[w]);
          return;
        }
        try {
          j.property(w, e[w]);
        } catch (N) {
          if (!_.compatibleConstructor(N, E))
            throw N;
          x === null && (x = N), m++;
        }
      }, this), a && y.length > 1 && m === y.length)
        throw x;
      return;
  }
  this.assert(
    b,
    "expected #{this} to " + h + "include " + S(e),
    "expected #{this} to not " + h + "include " + S(e)
  );
}
l(he, "include");
i.addChainableMethod("include", he, le);
i.addChainableMethod("contain", he, le);
i.addChainableMethod("contains", he, le);
i.addChainableMethod("includes", he, le);
i.addProperty("ok", function() {
  this.assert(
    f(this, "object"),
    "expected #{this} to be truthy",
    "expected #{this} to be falsy"
  );
});
i.addProperty("true", function() {
  this.assert(
    f(this, "object") === !0,
    "expected #{this} to be true",
    "expected #{this} to be false",
    !f(this, "negate")
  );
});
i.addProperty("numeric", function() {
  const e = f(this, "object");
  this.assert(
    ["Number", "BigInt"].includes(O(e)),
    "expected #{this} to be numeric",
    "expected #{this} to not be numeric",
    !f(this, "negate")
  );
});
i.addProperty("callable", function() {
  const e = f(this, "object"), t = f(this, "ssfi"), n = f(this, "message"), r = n ? `${n}: ` : "", o = f(this, "negate"), a = o ? `${r}expected ${S(e)} not to be a callable function` : `${r}expected ${S(e)} to be a callable function`, c = ["Function", "AsyncFunction", "GeneratorFunction", "AsyncGeneratorFunction"].includes(O(e));
  if (c && o || !c && !o)
    throw new E(
      a,
      void 0,
      t
    );
});
i.addProperty("false", function() {
  this.assert(
    f(this, "object") === !1,
    "expected #{this} to be false",
    "expected #{this} to be true",
    !!f(this, "negate")
  );
});
i.addProperty("null", function() {
  this.assert(
    f(this, "object") === null,
    "expected #{this} to be null",
    "expected #{this} not to be null"
  );
});
i.addProperty("undefined", function() {
  this.assert(
    f(this, "object") === void 0,
    "expected #{this} to be undefined",
    "expected #{this} not to be undefined"
  );
});
i.addProperty("NaN", function() {
  this.assert(
    we(f(this, "object")),
    "expected #{this} to be NaN",
    "expected #{this} not to be NaN"
  );
});
function gt() {
  var e = f(this, "object");
  this.assert(
    e != null,
    "expected #{this} to exist",
    "expected #{this} to not exist"
  );
}
l(gt, "assertExist");
i.addProperty("exist", gt);
i.addProperty("exists", gt);
i.addProperty("empty", function() {
  var e = f(this, "object"), t = f(this, "ssfi"), n = f(this, "message"), r;
  switch (n = n ? n + ": " : "", O(e).toLowerCase()) {
    case "array":
    case "string":
      r = e.length;
      break;
    case "map":
    case "set":
      r = e.size;
      break;
    case "weakmap":
    case "weakset":
      throw new E(
        n + ".empty was passed a weak collection",
        void 0,
        t
      );
    case "function":
      var o = n + ".empty was passed a function " + je(e);
      throw new E(o.trim(), void 0, t);
    default:
      if (e !== Object(e))
        throw new E(
          n + ".empty was passed non-string primitive " + S(e),
          void 0,
          t
        );
      r = Object.keys(e).length;
  }
  this.assert(
    r === 0,
    "expected #{this} to be empty",
    "expected #{this} not to be empty"
  );
});
function bt() {
  var e = f(this, "object"), t = O(e);
  this.assert(
    t === "Arguments",
    "expected #{this} to be arguments but got " + t,
    "expected #{this} to not be arguments"
  );
}
l(bt, "checkArguments");
i.addProperty("arguments", bt);
i.addProperty("Arguments", bt);
function Me(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object");
  if (f(this, "deep")) {
    var r = f(this, "lockSsfi");
    f(this, "lockSsfi", !0), this.eql(e), f(this, "lockSsfi", r);
  } else
    this.assert(
      e === n,
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{exp}",
      e,
      this._obj,
      !0
    );
}
l(Me, "assertEqual");
i.addMethod("equal", Me);
i.addMethod("equals", Me);
i.addMethod("eq", Me);
function yt(e, t) {
  t && f(this, "message", t);
  var n = f(this, "eql");
  this.assert(
    n(e, f(this, "object")),
    "expected #{this} to deeply equal #{exp}",
    "expected #{this} to not deeply equal #{exp}",
    e,
    this._obj,
    !0
  );
}
l(yt, "assertEql");
i.addMethod("eql", yt);
i.addMethod("eqls", yt);
function Oe(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = f(this, "doLength"), o = f(this, "message"), a = o ? o + ": " : "", c = f(this, "ssfi"), u = O(n).toLowerCase(), h = O(e).toLowerCase();
  if (r && u !== "map" && u !== "set" && new i(n, o, c, !0).to.have.property("length"), !r && u === "date" && h !== "date")
    throw new E(a + "the argument to above must be a date", void 0, c);
  if (!C(e) && (r || C(n)))
    throw new E(a + "the argument to above must be a number", void 0, c);
  if (!r && u !== "date" && !C(n)) {
    var p = u === "string" ? "'" + n + "'" : n;
    throw new E(a + "expected " + p + " to be a number or a date", void 0, c);
  }
  if (r) {
    var b = "length", y;
    u === "map" || u === "set" ? (b = "size", y = n.size) : y = n.length, this.assert(
      y > e,
      "expected #{this} to have a " + b + " above #{exp} but got #{act}",
      "expected #{this} to not have a " + b + " above #{exp}",
      e,
      y
    );
  } else
    this.assert(
      n > e,
      "expected #{this} to be above #{exp}",
      "expected #{this} to be at most #{exp}",
      e
    );
}
l(Oe, "assertAbove");
i.addMethod("above", Oe);
i.addMethod("gt", Oe);
i.addMethod("greaterThan", Oe);
function Ne(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = f(this, "doLength"), o = f(this, "message"), a = o ? o + ": " : "", c = f(this, "ssfi"), u = O(n).toLowerCase(), h = O(e).toLowerCase(), p, b = !0;
  if (r && u !== "map" && u !== "set" && new i(n, o, c, !0).to.have.property("length"), !r && u === "date" && h !== "date")
    p = a + "the argument to least must be a date";
  else if (!C(e) && (r || C(n)))
    p = a + "the argument to least must be a number";
  else if (!r && u !== "date" && !C(n)) {
    var y = u === "string" ? "'" + n + "'" : n;
    p = a + "expected " + y + " to be a number or a date";
  } else
    b = !1;
  if (b)
    throw new E(p, void 0, c);
  if (r) {
    var x = "length", m;
    u === "map" || u === "set" ? (x = "size", m = n.size) : m = n.length, this.assert(
      m >= e,
      "expected #{this} to have a " + x + " at least #{exp} but got #{act}",
      "expected #{this} to have a " + x + " below #{exp}",
      e,
      m
    );
  } else
    this.assert(
      n >= e,
      "expected #{this} to be at least #{exp}",
      "expected #{this} to be below #{exp}",
      e
    );
}
l(Ne, "assertLeast");
i.addMethod("least", Ne);
i.addMethod("gte", Ne);
i.addMethod("greaterThanOrEqual", Ne);
function Ae(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = f(this, "doLength"), o = f(this, "message"), a = o ? o + ": " : "", c = f(this, "ssfi"), u = O(n).toLowerCase(), h = O(e).toLowerCase(), p, b = !0;
  if (r && u !== "map" && u !== "set" && new i(n, o, c, !0).to.have.property("length"), !r && u === "date" && h !== "date")
    p = a + "the argument to below must be a date";
  else if (!C(e) && (r || C(n)))
    p = a + "the argument to below must be a number";
  else if (!r && u !== "date" && !C(n)) {
    var y = u === "string" ? "'" + n + "'" : n;
    p = a + "expected " + y + " to be a number or a date";
  } else
    b = !1;
  if (b)
    throw new E(p, void 0, c);
  if (r) {
    var x = "length", m;
    u === "map" || u === "set" ? (x = "size", m = n.size) : m = n.length, this.assert(
      m < e,
      "expected #{this} to have a " + x + " below #{exp} but got #{act}",
      "expected #{this} to not have a " + x + " below #{exp}",
      e,
      m
    );
  } else
    this.assert(
      n < e,
      "expected #{this} to be below #{exp}",
      "expected #{this} to be at least #{exp}",
      e
    );
}
l(Ae, "assertBelow");
i.addMethod("below", Ae);
i.addMethod("lt", Ae);
i.addMethod("lessThan", Ae);
function Te(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = f(this, "doLength"), o = f(this, "message"), a = o ? o + ": " : "", c = f(this, "ssfi"), u = O(n).toLowerCase(), h = O(e).toLowerCase(), p, b = !0;
  if (r && u !== "map" && u !== "set" && new i(n, o, c, !0).to.have.property("length"), !r && u === "date" && h !== "date")
    p = a + "the argument to most must be a date";
  else if (!C(e) && (r || C(n)))
    p = a + "the argument to most must be a number";
  else if (!r && u !== "date" && !C(n)) {
    var y = u === "string" ? "'" + n + "'" : n;
    p = a + "expected " + y + " to be a number or a date";
  } else
    b = !1;
  if (b)
    throw new E(p, void 0, c);
  if (r) {
    var x = "length", m;
    u === "map" || u === "set" ? (x = "size", m = n.size) : m = n.length, this.assert(
      m <= e,
      "expected #{this} to have a " + x + " at most #{exp} but got #{act}",
      "expected #{this} to have a " + x + " above #{exp}",
      e,
      m
    );
  } else
    this.assert(
      n <= e,
      "expected #{this} to be at most #{exp}",
      "expected #{this} to be above #{exp}",
      e
    );
}
l(Te, "assertMost");
i.addMethod("most", Te);
i.addMethod("lte", Te);
i.addMethod("lessThanOrEqual", Te);
i.addMethod("within", function(e, t, n) {
  n && f(this, "message", n);
  var r = f(this, "object"), o = f(this, "doLength"), a = f(this, "message"), c = a ? a + ": " : "", u = f(this, "ssfi"), h = O(r).toLowerCase(), p = O(e).toLowerCase(), b = O(t).toLowerCase(), y, x = !0, m = p === "date" && b === "date" ? e.toISOString() + ".." + t.toISOString() : e + ".." + t;
  if (o && h !== "map" && h !== "set" && new i(r, a, u, !0).to.have.property("length"), !o && h === "date" && (p !== "date" || b !== "date"))
    y = c + "the arguments to within must be dates";
  else if ((!C(e) || !C(t)) && (o || C(r)))
    y = c + "the arguments to within must be numbers";
  else if (!o && h !== "date" && !C(r)) {
    var w = h === "string" ? "'" + r + "'" : r;
    y = c + "expected " + w + " to be a number or a date";
  } else
    x = !1;
  if (x)
    throw new E(y, void 0, u);
  if (o) {
    var j = "length", N;
    h === "map" || h === "set" ? (j = "size", N = r.size) : N = r.length, this.assert(
      N >= e && N <= t,
      "expected #{this} to have a " + j + " within " + m,
      "expected #{this} to not have a " + j + " within " + m
    );
  } else
    this.assert(
      r >= e && r <= t,
      "expected #{this} to be within " + m,
      "expected #{this} to not be within " + m
    );
});
function mt(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = f(this, "ssfi"), o = f(this, "message");
  try {
    var a = n instanceof e;
  } catch (u) {
    throw u instanceof TypeError ? (o = o ? o + ": " : "", new E(
      o + "The instanceof assertion needs a constructor but " + O(e) + " was given.",
      void 0,
      r
    )) : u;
  }
  var c = je(e);
  c == null && (c = "an unnamed constructor"), this.assert(
    a,
    "expected #{this} to be an instance of " + c,
    "expected #{this} to not be an instance of " + c
  );
}
l(mt, "assertInstanceOf");
i.addMethod("instanceof", mt);
i.addMethod("instanceOf", mt);
function wt(e, t, n) {
  n && f(this, "message", n);
  var r = f(this, "nested"), o = f(this, "own"), a = f(this, "message"), c = f(this, "object"), u = f(this, "ssfi"), h = typeof e;
  if (a = a ? a + ": " : "", r) {
    if (h !== "string")
      throw new E(
        a + "the argument to property must be a string when using nested syntax",
        void 0,
        u
      );
  } else if (h !== "string" && h !== "number" && h !== "symbol")
    throw new E(
      a + "the argument to property must be a string, number, or symbol",
      void 0,
      u
    );
  if (r && o)
    throw new E(
      a + 'The "nested" and "own" flags cannot be combined.',
      void 0,
      u
    );
  if (c == null)
    throw new E(
      a + "Target cannot be null or undefined.",
      void 0,
      u
    );
  var p = f(this, "deep"), b = f(this, "negate"), y = r ? ot(c, e) : null, x = r ? y.value : c[e], m = p ? f(this, "eql") : (N, B) => N === B, w = "";
  p && (w += "deep "), o && (w += "own "), r && (w += "nested "), w += "property ";
  var j;
  o ? j = Object.prototype.hasOwnProperty.call(c, e) : r ? j = y.exists : j = Ee(c, e), (!b || arguments.length === 1) && this.assert(
    j,
    "expected #{this} to have " + w + S(e),
    "expected #{this} to not have " + w + S(e)
  ), arguments.length > 1 && this.assert(
    j && m(t, x),
    "expected #{this} to have " + w + S(e) + " of #{exp}, but got #{act}",
    "expected #{this} to not have " + w + S(e) + " of #{act}",
    t,
    x
  ), f(this, "object", x);
}
l(wt, "assertProperty");
i.addMethod("property", wt);
function vt(e, t, n) {
  f(this, "own", !0), wt.apply(this, arguments);
}
l(vt, "assertOwnProperty");
i.addMethod("ownProperty", vt);
i.addMethod("haveOwnProperty", vt);
function xt(e, t, n) {
  typeof t == "string" && (n = t, t = null), n && f(this, "message", n);
  var r = f(this, "object"), o = Object.getOwnPropertyDescriptor(Object(r), e), a = f(this, "eql");
  o && t ? this.assert(
    a(t, o),
    "expected the own property descriptor for " + S(e) + " on #{this} to match " + S(t) + ", got " + S(o),
    "expected the own property descriptor for " + S(e) + " on #{this} to not match " + S(t),
    t,
    o,
    !0
  ) : this.assert(
    o,
    "expected #{this} to have an own property descriptor for " + S(e),
    "expected #{this} to not have an own property descriptor for " + S(e)
  ), f(this, "object", o);
}
l(xt, "assertOwnPropertyDescriptor");
i.addMethod("ownPropertyDescriptor", xt);
i.addMethod("haveOwnPropertyDescriptor", xt);
function Pt() {
  f(this, "doLength", !0);
}
l(Pt, "assertLengthChain");
function St(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = O(n).toLowerCase(), o = f(this, "message"), a = f(this, "ssfi"), c = "length", u;
  switch (r) {
    case "map":
    case "set":
      c = "size", u = n.size;
      break;
    default:
      new i(n, o, a, !0).to.have.property("length"), u = n.length;
  }
  this.assert(
    u == e,
    "expected #{this} to have a " + c + " of #{exp} but got #{act}",
    "expected #{this} to not have a " + c + " of #{act}",
    e,
    u
  );
}
l(St, "assertLength");
i.addChainableMethod("length", St, Pt);
i.addChainableMethod("lengthOf", St, Pt);
function Et(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object");
  this.assert(
    e.exec(n),
    "expected #{this} to match " + e,
    "expected #{this} not to match " + e
  );
}
l(Et, "assertMatch");
i.addMethod("match", Et);
i.addMethod("matches", Et);
i.addMethod("string", function(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = f(this, "message"), o = f(this, "ssfi");
  new i(n, r, o, !0).is.a("string"), this.assert(
    ~n.indexOf(e),
    "expected #{this} to contain " + S(e),
    "expected #{this} to not contain " + S(e)
  );
});
function jt(e) {
  var t = f(this, "object"), n = O(t), r = O(e), o = f(this, "ssfi"), a = f(this, "deep"), c, u = "", h, p = !0, b = f(this, "message");
  b = b ? b + ": " : "";
  var y = b + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
  if (n === "Map" || n === "Set")
    u = a ? "deeply " : "", h = [], t.forEach(function(A, T) {
      h.push(T);
    }), r !== "Array" && (e = Array.prototype.slice.call(arguments));
  else {
    switch (h = ht(t), r) {
      case "Array":
        if (arguments.length > 1)
          throw new E(y, void 0, o);
        break;
      case "Object":
        if (arguments.length > 1)
          throw new E(y, void 0, o);
        e = Object.keys(e);
        break;
      default:
        e = Array.prototype.slice.call(arguments);
    }
    e = e.map(function(A) {
      return typeof A == "symbol" ? A : String(A);
    });
  }
  if (!e.length)
    throw new E(b + "keys required", void 0, o);
  var x = e.length, m = f(this, "any"), w = f(this, "all"), j = e, N = a ? f(this, "eql") : (A, T) => A === T;
  if (!m && !w && (w = !0), m && (p = j.some(function(A) {
    return h.some(function(T) {
      return N(A, T);
    });
  })), w && (p = j.every(function(A) {
    return h.some(function(T) {
      return N(A, T);
    });
  }), f(this, "contains") || (p = p && e.length == h.length)), x > 1) {
    e = e.map(function(A) {
      return S(A);
    });
    var B = e.pop();
    w && (c = e.join(", ") + ", and " + B), m && (c = e.join(", ") + ", or " + B);
  } else
    c = S(e[0]);
  c = (x > 1 ? "keys " : "key ") + c, c = (f(this, "contains") ? "contain " : "have ") + c, this.assert(
    p,
    "expected #{this} to " + u + c,
    "expected #{this} to not " + u + c,
    j.slice(0).sort(me),
    h.sort(me),
    !0
  );
}
l(jt, "assertKeys");
i.addMethod("keys", jt);
i.addMethod("key", jt);
function Ie(e, t, n) {
  n && f(this, "message", n);
  var r = f(this, "object"), o = f(this, "ssfi"), a = f(this, "message"), c = f(this, "negate") || !1;
  new i(r, a, o, !0).is.a("function"), (ve(e) || typeof e == "string") && (t = e, e = null);
  let u, h = !1;
  try {
    r();
  } catch (A) {
    h = !0, u = A;
  }
  var p = e === void 0 && t === void 0, b = !!(e && t), y = !1, x = !1;
  if (p || !p && !c) {
    var m = "an error";
    e instanceof Error ? m = "#{exp}" : e && (m = _.getConstructorName(e));
    let A = u;
    if (u instanceof Error)
      A = u.toString();
    else if (typeof u == "string")
      A = u;
    else if (u && (typeof u == "object" || typeof u == "function"))
      try {
        A = _.getConstructorName(u);
      } catch {
      }
    this.assert(
      h,
      "expected #{this} to throw " + m,
      "expected #{this} to not throw an error but #{act} was thrown",
      e && e.toString(),
      A
    );
  }
  if (e && u) {
    if (e instanceof Error) {
      var w = _.compatibleInstance(u, e);
      w === c && (b && c ? y = !0 : this.assert(
        c,
        "expected #{this} to throw #{exp} but #{act} was thrown",
        "expected #{this} to not throw #{exp}" + (u && !c ? " but #{act} was thrown" : ""),
        e.toString(),
        u.toString()
      ));
    }
    var j = _.compatibleConstructor(u, e);
    j === c && (b && c ? y = !0 : this.assert(
      c,
      "expected #{this} to throw #{exp} but #{act} was thrown",
      "expected #{this} to not throw #{exp}" + (u ? " but #{act} was thrown" : ""),
      e instanceof Error ? e.toString() : e && _.getConstructorName(e),
      u instanceof Error ? u.toString() : u && _.getConstructorName(u)
    ));
  }
  if (u && t !== void 0 && t !== null) {
    var N = "including";
    ve(t) && (N = "matching");
    var B = _.compatibleMessage(u, t);
    B === c && (b && c ? x = !0 : this.assert(
      c,
      "expected #{this} to throw error " + N + " #{exp} but got #{act}",
      "expected #{this} to throw error not " + N + " #{exp}",
      t,
      _.getMessage(u)
    ));
  }
  y && x && this.assert(
    c,
    "expected #{this} to throw #{exp} but #{act} was thrown",
    "expected #{this} to not throw #{exp}" + (u ? " but #{act} was thrown" : ""),
    e instanceof Error ? e.toString() : e && _.getConstructorName(e),
    u instanceof Error ? u.toString() : u && _.getConstructorName(u)
  ), f(this, "object", u);
}
l(Ie, "assertThrows");
i.addMethod("throw", Ie);
i.addMethod("throws", Ie);
i.addMethod("Throw", Ie);
function Mt(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = f(this, "itself"), o = typeof n == "function" && !r ? n.prototype[e] : n[e];
  this.assert(
    typeof o == "function",
    "expected #{this} to respond to " + S(e),
    "expected #{this} to not respond to " + S(e)
  );
}
l(Mt, "respondTo");
i.addMethod("respondTo", Mt);
i.addMethod("respondsTo", Mt);
i.addProperty("itself", function() {
  f(this, "itself", !0);
});
function Ot(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = e(n);
  this.assert(
    r,
    "expected #{this} to satisfy " + Z(e),
    "expected #{this} to not satisfy" + Z(e),
    !f(this, "negate"),
    r
  );
}
l(Ot, "satisfy");
i.addMethod("satisfy", Ot);
i.addMethod("satisfies", Ot);
function Nt(e, t, n) {
  n && f(this, "message", n);
  var r = f(this, "object"), o = f(this, "message"), a = f(this, "ssfi");
  new i(r, o, a, !0).is.numeric;
  let c = "A `delta` value is required for `closeTo`";
  if (t == null)
    throw new E(o ? `${o}: ${c}` : c, void 0, a);
  if (new i(t, o, a, !0).is.numeric, c = "A `expected` value is required for `closeTo`", e == null)
    throw new E(o ? `${o}: ${c}` : c, void 0, a);
  new i(e, o, a, !0).is.numeric;
  const u = /* @__PURE__ */ l((h) => h < 0n ? -h : h, "abs");
  this.assert(
    u(r - e) <= t,
    "expected #{this} to be close to " + e + " +/- " + t,
    "expected #{this} not to be close to " + e + " +/- " + t
  );
}
l(Nt, "closeTo");
i.addMethod("closeTo", Nt);
i.addMethod("approximately", Nt);
function Cn(e, t, n, r, o) {
  let a = Array.from(t), c = Array.from(e);
  if (!r) {
    if (c.length !== a.length)
      return !1;
    a = a.slice();
  }
  return c.every(function(u, h) {
    if (o)
      return n ? n(u, a[h]) : u === a[h];
    if (!n) {
      var p = a.indexOf(u);
      return p === -1 ? !1 : (r || a.splice(p, 1), !0);
    }
    return a.some(function(b, y) {
      return n(u, b) ? (r || a.splice(y, 1), !0) : !1;
    });
  });
}
l(Cn, "isSubsetOf");
i.addMethod("members", function(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = f(this, "message"), o = f(this, "ssfi");
  new i(n, r, o, !0).to.be.iterable, new i(e, r, o, !0).to.be.iterable;
  var a = f(this, "contains"), c = f(this, "ordered"), u, h, p;
  a ? (u = c ? "an ordered superset" : "a superset", h = "expected #{this} to be " + u + " of #{exp}", p = "expected #{this} to not be " + u + " of #{exp}") : (u = c ? "ordered members" : "members", h = "expected #{this} to have the same " + u + " as #{exp}", p = "expected #{this} to not have the same " + u + " as #{exp}");
  var b = f(this, "deep") ? f(this, "eql") : void 0;
  this.assert(
    Cn(e, n, b, a, c),
    h,
    p,
    e,
    n,
    !0
  );
});
i.addProperty("iterable", function(e) {
  e && f(this, "message", e);
  var t = f(this, "object");
  this.assert(
    t != null && t[Symbol.iterator],
    "expected #{this} to be an iterable",
    "expected #{this} to not be an iterable",
    t
  );
});
function Dn(e, t) {
  t && f(this, "message", t);
  var n = f(this, "object"), r = f(this, "message"), o = f(this, "ssfi"), a = f(this, "contains"), c = f(this, "deep"), u = f(this, "eql");
  new i(e, r, o, !0).to.be.an("array"), a ? this.assert(
    e.some(function(h) {
      return n.indexOf(h) > -1;
    }),
    "expected #{this} to contain one of #{exp}",
    "expected #{this} to not contain one of #{exp}",
    e,
    n
  ) : c ? this.assert(
    e.some(function(h) {
      return u(n, h);
    }),
    "expected #{this} to deeply equal one of #{exp}",
    "expected #{this} to deeply equal one of #{exp}",
    e,
    n
  ) : this.assert(
    e.indexOf(n) > -1,
    "expected #{this} to be one of #{exp}",
    "expected #{this} to not be one of #{exp}",
    e,
    n
  );
}
l(Dn, "oneOf");
i.addMethod("oneOf", Dn);
function At(e, t, n) {
  n && f(this, "message", n);
  var r = f(this, "object"), o = f(this, "message"), a = f(this, "ssfi");
  new i(r, o, a, !0).is.a("function");
  var c;
  t ? (new i(e, o, a, !0).to.have.property(t), c = e[t]) : (new i(e, o, a, !0).is.a("function"), c = e()), r();
  var u = t == null ? e() : e[t], h = t == null ? c : "." + t;
  f(this, "deltaMsgObj", h), f(this, "initialDeltaValue", c), f(this, "finalDeltaValue", u), f(this, "deltaBehavior", "change"), f(this, "realDelta", u !== c), this.assert(
    c !== u,
    "expected " + h + " to change",
    "expected " + h + " to not change"
  );
}
l(At, "assertChanges");
i.addMethod("change", At);
i.addMethod("changes", At);
function Tt(e, t, n) {
  n && f(this, "message", n);
  var r = f(this, "object"), o = f(this, "message"), a = f(this, "ssfi");
  new i(r, o, a, !0).is.a("function");
  var c;
  t ? (new i(e, o, a, !0).to.have.property(t), c = e[t]) : (new i(e, o, a, !0).is.a("function"), c = e()), new i(c, o, a, !0).is.a("number"), r();
  var u = t == null ? e() : e[t], h = t == null ? c : "." + t;
  f(this, "deltaMsgObj", h), f(this, "initialDeltaValue", c), f(this, "finalDeltaValue", u), f(this, "deltaBehavior", "increase"), f(this, "realDelta", u - c), this.assert(
    u - c > 0,
    "expected " + h + " to increase",
    "expected " + h + " to not increase"
  );
}
l(Tt, "assertIncreases");
i.addMethod("increase", Tt);
i.addMethod("increases", Tt);
function It(e, t, n) {
  n && f(this, "message", n);
  var r = f(this, "object"), o = f(this, "message"), a = f(this, "ssfi");
  new i(r, o, a, !0).is.a("function");
  var c;
  t ? (new i(e, o, a, !0).to.have.property(t), c = e[t]) : (new i(e, o, a, !0).is.a("function"), c = e()), new i(c, o, a, !0).is.a("number"), r();
  var u = t == null ? e() : e[t], h = t == null ? c : "." + t;
  f(this, "deltaMsgObj", h), f(this, "initialDeltaValue", c), f(this, "finalDeltaValue", u), f(this, "deltaBehavior", "decrease"), f(this, "realDelta", c - u), this.assert(
    u - c < 0,
    "expected " + h + " to decrease",
    "expected " + h + " to not decrease"
  );
}
l(It, "assertDecreases");
i.addMethod("decrease", It);
i.addMethod("decreases", It);
function $n(e, t) {
  t && f(this, "message", t);
  var n = f(this, "deltaMsgObj"), r = f(this, "initialDeltaValue"), o = f(this, "finalDeltaValue"), a = f(this, "deltaBehavior"), c = f(this, "realDelta"), u;
  a === "change" ? u = Math.abs(o - r) === Math.abs(e) : u = c === Math.abs(e), this.assert(
    u,
    "expected " + n + " to " + a + " by " + e,
    "expected " + n + " to not " + a + " by " + e
  );
}
l($n, "assertDelta");
i.addMethod("by", $n);
i.addProperty("extensible", function() {
  var e = f(this, "object"), t = e === Object(e) && Object.isExtensible(e);
  this.assert(
    t,
    "expected #{this} to be extensible",
    "expected #{this} to not be extensible"
  );
});
i.addProperty("sealed", function() {
  var e = f(this, "object"), t = e === Object(e) ? Object.isSealed(e) : !0;
  this.assert(
    t,
    "expected #{this} to be sealed",
    "expected #{this} to not be sealed"
  );
});
i.addProperty("frozen", function() {
  var e = f(this, "object"), t = e === Object(e) ? Object.isFrozen(e) : !0;
  this.assert(
    t,
    "expected #{this} to be frozen",
    "expected #{this} to not be frozen"
  );
});
i.addProperty("finite", function(e) {
  var t = f(this, "object");
  this.assert(
    typeof t == "number" && isFinite(t),
    "expected #{this} to be a finite number",
    "expected #{this} to not be a finite number"
  );
});
function k(e, t) {
  return new i(e, t);
}
l(k, "expect");
k.fail = function(e, t, n, r) {
  throw arguments.length < 2 && (n = e, e = void 0), n = n || "expect.fail()", new E(n, {
    actual: e,
    expected: t,
    operator: r
  }, k.fail);
};
var _n = {};
Xe(_n, {
  Should: () => ar,
  should: () => ir
});
function Ct() {
  function e() {
    return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new i(this.valueOf(), null, e) : new i(this, null, e);
  }
  l(e, "shouldGetter");
  function t(r) {
    Object.defineProperty(this, "should", {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    });
  }
  l(t, "shouldSetter"), Object.defineProperty(Object.prototype, "should", {
    set: t,
    get: e,
    configurable: !0
  });
  var n = {};
  return n.fail = function(r, o, a, c) {
    throw arguments.length < 2 && (a = r, r = void 0), a = a || "should.fail()", new E(a, {
      actual: r,
      expected: o,
      operator: c
    }, n.fail);
  }, n.equal = function(r, o, a) {
    new i(r, a).to.equal(o);
  }, n.Throw = function(r, o, a, c) {
    new i(r, c).to.Throw(o, a);
  }, n.exist = function(r, o) {
    new i(r, o).to.exist;
  }, n.not = {}, n.not.equal = function(r, o, a) {
    new i(r, a).to.not.equal(o);
  }, n.not.Throw = function(r, o, a, c) {
    new i(r, c).to.not.Throw(o, a);
  }, n.not.exist = function(r, o) {
    new i(r, o).to.not.exist;
  }, n.throw = n.Throw, n.not.throw = n.not.Throw, n;
}
l(Ct, "loadShould");
var ir = Ct, ar = Ct;
function s(e, t) {
  var n = new i(null, null, s, !0);
  n.assert(
    e,
    t,
    "[ negation message unavailable ]"
  );
}
l(s, "assert");
s.fail = function(e, t, n, r) {
  throw arguments.length < 2 && (n = e, e = void 0), n = n || "assert.fail()", new E(n, {
    actual: e,
    expected: t,
    operator: r
  }, s.fail);
};
s.isOk = function(e, t) {
  new i(e, t, s.isOk, !0).is.ok;
};
s.isNotOk = function(e, t) {
  new i(e, t, s.isNotOk, !0).is.not.ok;
};
s.equal = function(e, t, n) {
  var r = new i(e, n, s.equal, !0);
  r.assert(
    t == v(r, "object"),
    "expected #{this} to equal #{exp}",
    "expected #{this} to not equal #{act}",
    t,
    e,
    !0
  );
};
s.notEqual = function(e, t, n) {
  var r = new i(e, n, s.notEqual, !0);
  r.assert(
    t != v(r, "object"),
    "expected #{this} to not equal #{exp}",
    "expected #{this} to equal #{act}",
    t,
    e,
    !0
  );
};
s.strictEqual = function(e, t, n) {
  new i(e, n, s.strictEqual, !0).to.equal(t);
};
s.notStrictEqual = function(e, t, n) {
  new i(e, n, s.notStrictEqual, !0).to.not.equal(t);
};
s.deepEqual = s.deepStrictEqual = function(e, t, n) {
  new i(e, n, s.deepEqual, !0).to.eql(t);
};
s.notDeepEqual = function(e, t, n) {
  new i(e, n, s.notDeepEqual, !0).to.not.eql(t);
};
s.isAbove = function(e, t, n) {
  new i(e, n, s.isAbove, !0).to.be.above(t);
};
s.isAtLeast = function(e, t, n) {
  new i(e, n, s.isAtLeast, !0).to.be.least(t);
};
s.isBelow = function(e, t, n) {
  new i(e, n, s.isBelow, !0).to.be.below(t);
};
s.isAtMost = function(e, t, n) {
  new i(e, n, s.isAtMost, !0).to.be.most(t);
};
s.isTrue = function(e, t) {
  new i(e, t, s.isTrue, !0).is.true;
};
s.isNotTrue = function(e, t) {
  new i(e, t, s.isNotTrue, !0).to.not.equal(!0);
};
s.isFalse = function(e, t) {
  new i(e, t, s.isFalse, !0).is.false;
};
s.isNotFalse = function(e, t) {
  new i(e, t, s.isNotFalse, !0).to.not.equal(!1);
};
s.isNull = function(e, t) {
  new i(e, t, s.isNull, !0).to.equal(null);
};
s.isNotNull = function(e, t) {
  new i(e, t, s.isNotNull, !0).to.not.equal(null);
};
s.isNaN = function(e, t) {
  new i(e, t, s.isNaN, !0).to.be.NaN;
};
s.isNotNaN = function(e, t) {
  new i(e, t, s.isNotNaN, !0).not.to.be.NaN;
};
s.exists = function(e, t) {
  new i(e, t, s.exists, !0).to.exist;
};
s.notExists = function(e, t) {
  new i(e, t, s.notExists, !0).to.not.exist;
};
s.isUndefined = function(e, t) {
  new i(e, t, s.isUndefined, !0).to.equal(void 0);
};
s.isDefined = function(e, t) {
  new i(e, t, s.isDefined, !0).to.not.equal(void 0);
};
s.isCallable = function(e, t) {
  new i(e, t, s.isCallable, !0).is.callable;
};
s.isNotCallable = function(e, t) {
  new i(e, t, s.isNotCallable, !0).is.not.callable;
};
s.isObject = function(e, t) {
  new i(e, t, s.isObject, !0).to.be.a("object");
};
s.isNotObject = function(e, t) {
  new i(e, t, s.isNotObject, !0).to.not.be.a("object");
};
s.isArray = function(e, t) {
  new i(e, t, s.isArray, !0).to.be.an("array");
};
s.isNotArray = function(e, t) {
  new i(e, t, s.isNotArray, !0).to.not.be.an("array");
};
s.isString = function(e, t) {
  new i(e, t, s.isString, !0).to.be.a("string");
};
s.isNotString = function(e, t) {
  new i(e, t, s.isNotString, !0).to.not.be.a("string");
};
s.isNumber = function(e, t) {
  new i(e, t, s.isNumber, !0).to.be.a("number");
};
s.isNotNumber = function(e, t) {
  new i(e, t, s.isNotNumber, !0).to.not.be.a("number");
};
s.isNumeric = function(e, t) {
  new i(e, t, s.isNumeric, !0).is.numeric;
};
s.isNotNumeric = function(e, t) {
  new i(e, t, s.isNotNumeric, !0).is.not.numeric;
};
s.isFinite = function(e, t) {
  new i(e, t, s.isFinite, !0).to.be.finite;
};
s.isBoolean = function(e, t) {
  new i(e, t, s.isBoolean, !0).to.be.a("boolean");
};
s.isNotBoolean = function(e, t) {
  new i(e, t, s.isNotBoolean, !0).to.not.be.a("boolean");
};
s.typeOf = function(e, t, n) {
  new i(e, n, s.typeOf, !0).to.be.a(t);
};
s.notTypeOf = function(e, t, n) {
  new i(e, n, s.notTypeOf, !0).to.not.be.a(t);
};
s.instanceOf = function(e, t, n) {
  new i(e, n, s.instanceOf, !0).to.be.instanceOf(t);
};
s.notInstanceOf = function(e, t, n) {
  new i(e, n, s.notInstanceOf, !0).to.not.be.instanceOf(t);
};
s.include = function(e, t, n) {
  new i(e, n, s.include, !0).include(t);
};
s.notInclude = function(e, t, n) {
  new i(e, n, s.notInclude, !0).not.include(t);
};
s.deepInclude = function(e, t, n) {
  new i(e, n, s.deepInclude, !0).deep.include(t);
};
s.notDeepInclude = function(e, t, n) {
  new i(e, n, s.notDeepInclude, !0).not.deep.include(t);
};
s.nestedInclude = function(e, t, n) {
  new i(e, n, s.nestedInclude, !0).nested.include(t);
};
s.notNestedInclude = function(e, t, n) {
  new i(e, n, s.notNestedInclude, !0).not.nested.include(t);
};
s.deepNestedInclude = function(e, t, n) {
  new i(e, n, s.deepNestedInclude, !0).deep.nested.include(t);
};
s.notDeepNestedInclude = function(e, t, n) {
  new i(e, n, s.notDeepNestedInclude, !0).not.deep.nested.include(t);
};
s.ownInclude = function(e, t, n) {
  new i(e, n, s.ownInclude, !0).own.include(t);
};
s.notOwnInclude = function(e, t, n) {
  new i(e, n, s.notOwnInclude, !0).not.own.include(t);
};
s.deepOwnInclude = function(e, t, n) {
  new i(e, n, s.deepOwnInclude, !0).deep.own.include(t);
};
s.notDeepOwnInclude = function(e, t, n) {
  new i(e, n, s.notDeepOwnInclude, !0).not.deep.own.include(t);
};
s.match = function(e, t, n) {
  new i(e, n, s.match, !0).to.match(t);
};
s.notMatch = function(e, t, n) {
  new i(e, n, s.notMatch, !0).to.not.match(t);
};
s.property = function(e, t, n) {
  new i(e, n, s.property, !0).to.have.property(t);
};
s.notProperty = function(e, t, n) {
  new i(e, n, s.notProperty, !0).to.not.have.property(t);
};
s.propertyVal = function(e, t, n, r) {
  new i(e, r, s.propertyVal, !0).to.have.property(t, n);
};
s.notPropertyVal = function(e, t, n, r) {
  new i(e, r, s.notPropertyVal, !0).to.not.have.property(t, n);
};
s.deepPropertyVal = function(e, t, n, r) {
  new i(e, r, s.deepPropertyVal, !0).to.have.deep.property(t, n);
};
s.notDeepPropertyVal = function(e, t, n, r) {
  new i(e, r, s.notDeepPropertyVal, !0).to.not.have.deep.property(t, n);
};
s.ownProperty = function(e, t, n) {
  new i(e, n, s.ownProperty, !0).to.have.own.property(t);
};
s.notOwnProperty = function(e, t, n) {
  new i(e, n, s.notOwnProperty, !0).to.not.have.own.property(t);
};
s.ownPropertyVal = function(e, t, n, r) {
  new i(e, r, s.ownPropertyVal, !0).to.have.own.property(t, n);
};
s.notOwnPropertyVal = function(e, t, n, r) {
  new i(e, r, s.notOwnPropertyVal, !0).to.not.have.own.property(t, n);
};
s.deepOwnPropertyVal = function(e, t, n, r) {
  new i(e, r, s.deepOwnPropertyVal, !0).to.have.deep.own.property(t, n);
};
s.notDeepOwnPropertyVal = function(e, t, n, r) {
  new i(e, r, s.notDeepOwnPropertyVal, !0).to.not.have.deep.own.property(t, n);
};
s.nestedProperty = function(e, t, n) {
  new i(e, n, s.nestedProperty, !0).to.have.nested.property(t);
};
s.notNestedProperty = function(e, t, n) {
  new i(e, n, s.notNestedProperty, !0).to.not.have.nested.property(t);
};
s.nestedPropertyVal = function(e, t, n, r) {
  new i(e, r, s.nestedPropertyVal, !0).to.have.nested.property(t, n);
};
s.notNestedPropertyVal = function(e, t, n, r) {
  new i(e, r, s.notNestedPropertyVal, !0).to.not.have.nested.property(t, n);
};
s.deepNestedPropertyVal = function(e, t, n, r) {
  new i(e, r, s.deepNestedPropertyVal, !0).to.have.deep.nested.property(t, n);
};
s.notDeepNestedPropertyVal = function(e, t, n, r) {
  new i(e, r, s.notDeepNestedPropertyVal, !0).to.not.have.deep.nested.property(t, n);
};
s.lengthOf = function(e, t, n) {
  new i(e, n, s.lengthOf, !0).to.have.lengthOf(t);
};
s.hasAnyKeys = function(e, t, n) {
  new i(e, n, s.hasAnyKeys, !0).to.have.any.keys(t);
};
s.hasAllKeys = function(e, t, n) {
  new i(e, n, s.hasAllKeys, !0).to.have.all.keys(t);
};
s.containsAllKeys = function(e, t, n) {
  new i(e, n, s.containsAllKeys, !0).to.contain.all.keys(t);
};
s.doesNotHaveAnyKeys = function(e, t, n) {
  new i(e, n, s.doesNotHaveAnyKeys, !0).to.not.have.any.keys(t);
};
s.doesNotHaveAllKeys = function(e, t, n) {
  new i(e, n, s.doesNotHaveAllKeys, !0).to.not.have.all.keys(t);
};
s.hasAnyDeepKeys = function(e, t, n) {
  new i(e, n, s.hasAnyDeepKeys, !0).to.have.any.deep.keys(t);
};
s.hasAllDeepKeys = function(e, t, n) {
  new i(e, n, s.hasAllDeepKeys, !0).to.have.all.deep.keys(t);
};
s.containsAllDeepKeys = function(e, t, n) {
  new i(e, n, s.containsAllDeepKeys, !0).to.contain.all.deep.keys(t);
};
s.doesNotHaveAnyDeepKeys = function(e, t, n) {
  new i(e, n, s.doesNotHaveAnyDeepKeys, !0).to.not.have.any.deep.keys(t);
};
s.doesNotHaveAllDeepKeys = function(e, t, n) {
  new i(e, n, s.doesNotHaveAllDeepKeys, !0).to.not.have.all.deep.keys(t);
};
s.throws = function(e, t, n, r) {
  (typeof t == "string" || t instanceof RegExp) && (n = t, t = null);
  var o = new i(e, r, s.throws, !0).to.throw(t, n);
  return v(o, "object");
};
s.doesNotThrow = function(e, t, n, r) {
  (typeof t == "string" || t instanceof RegExp) && (n = t, t = null), new i(e, r, s.doesNotThrow, !0).to.not.throw(t, n);
};
s.operator = function(e, t, n, r) {
  var o;
  switch (t) {
    case "==":
      o = e == n;
      break;
    case "===":
      o = e === n;
      break;
    case ">":
      o = e > n;
      break;
    case ">=":
      o = e >= n;
      break;
    case "<":
      o = e < n;
      break;
    case "<=":
      o = e <= n;
      break;
    case "!=":
      o = e != n;
      break;
    case "!==":
      o = e !== n;
      break;
    default:
      throw r = r && r + ": ", new E(
        r + 'Invalid operator "' + t + '"',
        void 0,
        s.operator
      );
  }
  var a = new i(o, r, s.operator, !0);
  a.assert(
    v(a, "object") === !0,
    "expected " + S(e) + " to be " + t + " " + S(n),
    "expected " + S(e) + " to not be " + t + " " + S(n)
  );
};
s.closeTo = function(e, t, n, r) {
  new i(e, r, s.closeTo, !0).to.be.closeTo(t, n);
};
s.approximately = function(e, t, n, r) {
  new i(e, r, s.approximately, !0).to.be.approximately(t, n);
};
s.sameMembers = function(e, t, n) {
  new i(e, n, s.sameMembers, !0).to.have.same.members(t);
};
s.notSameMembers = function(e, t, n) {
  new i(e, n, s.notSameMembers, !0).to.not.have.same.members(t);
};
s.sameDeepMembers = function(e, t, n) {
  new i(e, n, s.sameDeepMembers, !0).to.have.same.deep.members(t);
};
s.notSameDeepMembers = function(e, t, n) {
  new i(e, n, s.notSameDeepMembers, !0).to.not.have.same.deep.members(t);
};
s.sameOrderedMembers = function(e, t, n) {
  new i(e, n, s.sameOrderedMembers, !0).to.have.same.ordered.members(t);
};
s.notSameOrderedMembers = function(e, t, n) {
  new i(e, n, s.notSameOrderedMembers, !0).to.not.have.same.ordered.members(t);
};
s.sameDeepOrderedMembers = function(e, t, n) {
  new i(e, n, s.sameDeepOrderedMembers, !0).to.have.same.deep.ordered.members(t);
};
s.notSameDeepOrderedMembers = function(e, t, n) {
  new i(e, n, s.notSameDeepOrderedMembers, !0).to.not.have.same.deep.ordered.members(t);
};
s.includeMembers = function(e, t, n) {
  new i(e, n, s.includeMembers, !0).to.include.members(t);
};
s.notIncludeMembers = function(e, t, n) {
  new i(e, n, s.notIncludeMembers, !0).to.not.include.members(t);
};
s.includeDeepMembers = function(e, t, n) {
  new i(e, n, s.includeDeepMembers, !0).to.include.deep.members(t);
};
s.notIncludeDeepMembers = function(e, t, n) {
  new i(e, n, s.notIncludeDeepMembers, !0).to.not.include.deep.members(t);
};
s.includeOrderedMembers = function(e, t, n) {
  new i(e, n, s.includeOrderedMembers, !0).to.include.ordered.members(t);
};
s.notIncludeOrderedMembers = function(e, t, n) {
  new i(e, n, s.notIncludeOrderedMembers, !0).to.not.include.ordered.members(t);
};
s.includeDeepOrderedMembers = function(e, t, n) {
  new i(e, n, s.includeDeepOrderedMembers, !0).to.include.deep.ordered.members(t);
};
s.notIncludeDeepOrderedMembers = function(e, t, n) {
  new i(e, n, s.notIncludeDeepOrderedMembers, !0).to.not.include.deep.ordered.members(t);
};
s.oneOf = function(e, t, n) {
  new i(e, n, s.oneOf, !0).to.be.oneOf(t);
};
s.isIterable = function(e, t) {
  if (e == null || !e[Symbol.iterator])
    throw t = t ? `${t} expected ${S(e)} to be an iterable` : `expected ${S(e)} to be an iterable`, new E(
      t,
      void 0,
      s.isIterable
    );
};
s.changes = function(e, t, n, r) {
  arguments.length === 3 && typeof t == "function" && (r = n, n = null), new i(e, r, s.changes, !0).to.change(t, n);
};
s.changesBy = function(e, t, n, r, o) {
  if (arguments.length === 4 && typeof t == "function") {
    var a = r;
    r = n, o = a;
  } else arguments.length === 3 && (r = n, n = null);
  new i(e, o, s.changesBy, !0).to.change(t, n).by(r);
};
s.doesNotChange = function(e, t, n, r) {
  return arguments.length === 3 && typeof t == "function" && (r = n, n = null), new i(e, r, s.doesNotChange, !0).to.not.change(t, n);
};
s.changesButNotBy = function(e, t, n, r, o) {
  if (arguments.length === 4 && typeof t == "function") {
    var a = r;
    r = n, o = a;
  } else arguments.length === 3 && (r = n, n = null);
  new i(e, o, s.changesButNotBy, !0).to.change(t, n).but.not.by(r);
};
s.increases = function(e, t, n, r) {
  return arguments.length === 3 && typeof t == "function" && (r = n, n = null), new i(e, r, s.increases, !0).to.increase(t, n);
};
s.increasesBy = function(e, t, n, r, o) {
  if (arguments.length === 4 && typeof t == "function") {
    var a = r;
    r = n, o = a;
  } else arguments.length === 3 && (r = n, n = null);
  new i(e, o, s.increasesBy, !0).to.increase(t, n).by(r);
};
s.doesNotIncrease = function(e, t, n, r) {
  return arguments.length === 3 && typeof t == "function" && (r = n, n = null), new i(e, r, s.doesNotIncrease, !0).to.not.increase(t, n);
};
s.increasesButNotBy = function(e, t, n, r, o) {
  if (arguments.length === 4 && typeof t == "function") {
    var a = r;
    r = n, o = a;
  } else arguments.length === 3 && (r = n, n = null);
  new i(e, o, s.increasesButNotBy, !0).to.increase(t, n).but.not.by(r);
};
s.decreases = function(e, t, n, r) {
  return arguments.length === 3 && typeof t == "function" && (r = n, n = null), new i(e, r, s.decreases, !0).to.decrease(t, n);
};
s.decreasesBy = function(e, t, n, r, o) {
  if (arguments.length === 4 && typeof t == "function") {
    var a = r;
    r = n, o = a;
  } else arguments.length === 3 && (r = n, n = null);
  new i(e, o, s.decreasesBy, !0).to.decrease(t, n).by(r);
};
s.doesNotDecrease = function(e, t, n, r) {
  return arguments.length === 3 && typeof t == "function" && (r = n, n = null), new i(e, r, s.doesNotDecrease, !0).to.not.decrease(t, n);
};
s.doesNotDecreaseBy = function(e, t, n, r, o) {
  if (arguments.length === 4 && typeof t == "function") {
    var a = r;
    r = n, o = a;
  } else arguments.length === 3 && (r = n, n = null);
  return new i(e, o, s.doesNotDecreaseBy, !0).to.not.decrease(t, n).by(r);
};
s.decreasesButNotBy = function(e, t, n, r, o) {
  if (arguments.length === 4 && typeof t == "function") {
    var a = r;
    r = n, o = a;
  } else arguments.length === 3 && (r = n, n = null);
  new i(e, o, s.decreasesButNotBy, !0).to.decrease(t, n).but.not.by(r);
};
s.ifError = function(e) {
  if (e)
    throw e;
};
s.isExtensible = function(e, t) {
  new i(e, t, s.isExtensible, !0).to.be.extensible;
};
s.isNotExtensible = function(e, t) {
  new i(e, t, s.isNotExtensible, !0).to.not.be.extensible;
};
s.isSealed = function(e, t) {
  new i(e, t, s.isSealed, !0).to.be.sealed;
};
s.isNotSealed = function(e, t) {
  new i(e, t, s.isNotSealed, !0).to.not.be.sealed;
};
s.isFrozen = function(e, t) {
  new i(e, t, s.isFrozen, !0).to.be.frozen;
};
s.isNotFrozen = function(e, t) {
  new i(e, t, s.isNotFrozen, !0).to.not.be.frozen;
};
s.isEmpty = function(e, t) {
  new i(e, t, s.isEmpty, !0).to.be.empty;
};
s.isNotEmpty = function(e, t) {
  new i(e, t, s.isNotEmpty, !0).to.not.be.empty;
};
(/* @__PURE__ */ l(function e(t, n) {
  return s[n] = s[t], e;
}, "alias"))("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen")("isEmpty", "empty")("isNotEmpty", "notEmpty")("isCallable", "isFunction")("isNotCallable", "isNotFunction");
var Kt = [];
function qn(e) {
  const t = {
    AssertionError: E,
    util: pe,
    config: $,
    expect: k,
    assert: s,
    Assertion: i,
    ..._n
  };
  return ~Kt.indexOf(e) || (e(t, pe), Kt.push(e)), t;
}
l(qn, "use");
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*! Bundled license information:

deep-eql/index.js:
  (*!
   * deep-eql
   * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
   * MIT Licensed
   *)
  (*!
   * Check to see if the MemoizeMap has recorded a result of the two operands
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @returns {Boolean|null} result
  *)
  (*!
   * Set the result of the equality into the MemoizeMap
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {MemoizeMap} memoizeMap
   * @param {Boolean} result
  *)
  (*!
   * Primary Export
   *)
  (*!
   * The main logic of the `deepEqual` function.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (optional) Additional options
   * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
   * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
      complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
      references to blow the stack.
   * @return {Boolean} equal match
  *)
  (*!
   * Compare two Regular Expressions for equality.
   *
   * @param {RegExp} leftHandOperand
   * @param {RegExp} rightHandOperand
   * @return {Boolean} result
   *)
  (*!
   * Compare two Sets/Maps for equality. Faster than other equality functions.
   *
   * @param {Set} leftHandOperand
   * @param {Set} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Simple equality for generator objects such as those returned by generator functions.
   *
   * @param {Iterable} leftHandOperand
   * @param {Iterable} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Determine if the given object has an @@iterator function.
   *
   * @param {Object} target
   * @return {Boolean} `true` if the object has an @@iterator function.
   *)
  (*!
   * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
   * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
   *
   * @param {Object} target
   * @returns {Array} an array of entries from the @@iterator function
   *)
  (*!
   * Gets all entries from a Generator. This will consume the generator - which could have side effects.
   *
   * @param {Generator} target
   * @returns {Array} an array of entries from the Generator.
   *)
  (*!
   * Gets all own and inherited enumerable keys from a target.
   *
   * @param {Object} target
   * @returns {Array} an array of own and inherited enumerable keys from the target.
   *)
  (*!
   * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
   * each key. If any value of the given key is not equal, the function will return false (early).
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
   * for each enumerable key in the object.
   *
   * @param {Mixed} leftHandOperand
   * @param {Mixed} rightHandOperand
   * @param {Object} [options] (Optional)
   * @return {Boolean} result
   *)
  (*!
   * Returns true if the argument is a primitive.
   *
   * This intentionally returns true for all objects that can be compared by reference,
   * including functions and symbols.
   *
   * @param {Mixed} value
   * @return {Boolean} result
   *)
*/
function Dt(e) {
  return e instanceof Error || Object.prototype.toString.call(e) === "[object Error]";
}
function cr(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
function ur(e, t) {
  return Dt(t) && e === t;
}
function fr(e, t) {
  return Dt(t) ? e.constructor === t.constructor || e instanceof t.constructor : (typeof t == "object" || typeof t == "function") && t.prototype ? e.constructor === t || e instanceof t : !1;
}
function lr(e, t) {
  const n = typeof e == "string" ? e : e.message;
  return cr(t) ? t.test(n) : typeof t == "string" ? n.indexOf(t) !== -1 : !1;
}
function hr(e) {
  let t = e;
  return Dt(e) ? t = e.constructor.name : typeof e == "function" && (t = e.name, t === "" && (t = new e().name || t)), t;
}
function dr(e) {
  let t = "";
  return e && e.message ? t = e.message : typeof e == "string" && (t = e), t;
}
const pr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compatibleConstructor: fr,
  compatibleInstance: ur,
  compatibleMessage: lr,
  getConstructorName: hr,
  getMessage: dr
}, Symbol.toStringTag, { value: "Module" }));
let J = pr;
function gr(e, t) {
  const n = e.Assertion, r = e.assert, o = t.proxify;
  t.checkError && (J = t.checkError);
  function a(d) {
    return typeof d.catch != "function" && typeof d.always == "function" && typeof d.done == "function" && typeof d.fail == "function" && typeof d.pipe == "function" && typeof d.progress == "function" && typeof d.state == "function";
  }
  function c(d) {
    if (typeof d._obj.then != "function")
      throw new TypeError(
        t.inspect(d._obj) + " is not a thenable."
      );
    if (a(d._obj))
      throw new TypeError(
        "Chai as Promised is incompatible with thenables of jQuery<3.0.0, sorry! Please upgrade jQuery or use another Promises/A+ compatible library (see http://promisesaplus.com/)."
      );
  }
  function u(d) {
    return o === void 0 ? d : o(d);
  }
  function h(d, g) {
    t.addMethod(n.prototype, d, function() {
      return c(this), g.apply(this, arguments);
    });
  }
  function p(d, g) {
    t.addProperty(n.prototype, d, function() {
      return c(this), u(g.apply(this, arguments));
    });
  }
  function b(d, g) {
    d.then(() => g(), g);
  }
  function y(d, g, P) {
    d.assert(!0, null, g, P.expected, P.actual);
  }
  function x(d, g, P) {
    d.assert(!1, g, null, P.expected, P.actual);
  }
  function m(d) {
    return typeof d.then == "function" ? d : d._obj;
  }
  function w(d) {
    return d instanceof Error ? d.toString() : J.getConstructorName(d);
  }
  const j = Object.getOwnPropertyNames(n.prototype), N = {};
  for (const d of j)
    N[d] = Object.getOwnPropertyDescriptor(
      n.prototype,
      d
    );
  p("fulfilled", function() {
    const d = m(this).then(
      (g) => (y(
        this,
        "expected promise not to be fulfilled but it was fulfilled with #{act}",
        { actual: g }
      ), g),
      (g) => (x(
        this,
        "expected promise to be fulfilled but it was rejected with #{act}",
        { actual: w(g) }
      ), g)
    );
    return de(this, d), this;
  }), p("rejected", function() {
    const d = m(this).then(
      (g) => (x(
        this,
        "expected promise to be rejected but it was fulfilled with #{act}",
        { actual: g }
      ), g),
      (g) => (y(
        this,
        "expected promise not to be rejected but it was rejected with #{act}",
        { actual: w(g) }
      ), g)
    );
    return de(this, d), this;
  }), h("rejectedWith", function(d, g, P) {
    let I = null;
    const q = t.flag(this, "negate") || !1;
    if (d === void 0 && g === void 0 && P === void 0)
      return this.rejected;
    P !== void 0 && t.flag(this, "message", P), d instanceof RegExp || typeof d == "string" ? (g = d, d = null) : d && d instanceof Error ? I = d.toString() : typeof d == "function" ? I = J.getConstructorName(d) : d = null;
    const F = !!(d && g);
    let U = "including";
    g instanceof RegExp && (U = "matching");
    const Fn = m(this).then(
      (R) => {
        let L = null, H = null;
        return d ? (L = "expected promise to be rejected with #{exp} but it was fulfilled with #{act}", H = I) : g && (L = `expected promise to be rejected with an error ${U} #{exp} but it was fulfilled with #{act}`, H = g), x(this, L, { expected: H, actual: R }), R;
      },
      (R) => {
        const L = d && (d instanceof Error ? J.compatibleInstance(R, d) : J.compatibleConstructor(R, d)), H = g === R || g && R && J.compatibleMessage(R, g), $t = w(R);
        return q && F ? L && H && this.assert(
          !0,
          null,
          "expected promise not to be rejected with #{exp} but it was rejected with #{act}",
          I,
          $t
        ) : (d && this.assert(
          L,
          "expected promise to be rejected with #{exp} but it was rejected with #{act}",
          "expected promise not to be rejected with #{exp} but it was rejected with #{act}",
          I,
          $t
        ), g && this.assert(
          H,
          `expected promise to be rejected with an error ${U} #{exp} but got #{act}`,
          `expected promise not to be rejected with an error ${U} #{exp}`,
          g,
          J.getMessage(R)
        )), R;
      }
    );
    return de(this, Fn), this;
  }), p("eventually", function() {
    return t.flag(this, "eventually", !0), this;
  }), h("notify", function(d) {
    return b(m(this), d), this;
  }), h("become", function(d, g) {
    return this.eventually.deep.equal(d, g);
  }), j.filter((d) => d !== "assert" && typeof N[d].value == "function").forEach((d) => {
    n.overwriteMethod(
      d,
      (g) => function() {
        return T(g, this, arguments);
      }
    );
  }), j.filter((d) => d !== "_obj" && typeof N[d].get == "function").forEach((d) => {
    Object.prototype.hasOwnProperty.call(
      n.prototype.__methods,
      d
    ) ? n.overwriteChainableMethod(
      d,
      (P) => function() {
        return T(P, this, arguments);
      },
      (P) => function() {
        return T(P, this);
      }
    ) : n.overwriteProperty(
      d,
      (P) => function() {
        return u(
          T(P, this)
        );
      }
    );
  });
  function T(d, g, P) {
    if (!t.flag(g, "eventually"))
      return d.apply(g, P), g;
    const I = m(g).then((q) => (g._obj = q, t.flag(g, "eventually", !1), P && yr(P))).then((q) => (d.apply(g, q), g._obj));
    return de(g, I), g;
  }
  const M = Object.getOwnPropertyNames(r).filter(
    (d) => typeof r[d] == "function"
  );
  r.isFulfilled = (d, g) => new n(d, g).to.be.fulfilled, r.isRejected = (d, g, P, I) => new n(d, I).to.be.rejectedWith(g, P, I), r.becomes = (d, g, P) => r.eventually.deepEqual(d, g, P), r.doesNotBecome = (d, g, P) => r.eventually.notDeepEqual(d, g, P), r.eventually = {}, M.forEach((d) => {
    r.eventually[d] = function(g) {
      const P = Array.prototype.slice.call(arguments, 1);
      let I;
      const q = arguments[r[d].length - 1];
      typeof q == "string" && (I = (U) => {
        throw new e.AssertionError(
          `${q}

Original reason: ${t.inspect(U)}`
        );
      });
      const F = g.then(
        (U) => r[d].apply(
          r,
          [U].concat(P)
        ),
        I
      );
      return F.notify = (U) => {
        b(F, U);
      }, F;
    };
  });
}
function br(e, t) {
  e.then = t.then.bind(t);
}
function de(e, t) {
  br(e, t);
}
function yr(e) {
  return e;
}
const D = [];
for (let e = 0; e < 256; ++e)
  D.push((e + 256).toString(16).slice(1));
function mr(e, t = 0) {
  return (D[e[t + 0]] + D[e[t + 1]] + D[e[t + 2]] + D[e[t + 3]] + "-" + D[e[t + 4]] + D[e[t + 5]] + "-" + D[e[t + 6]] + D[e[t + 7]] + "-" + D[e[t + 8]] + D[e[t + 9]] + "-" + D[e[t + 10]] + D[e[t + 11]] + D[e[t + 12]] + D[e[t + 13]] + D[e[t + 14]] + D[e[t + 15]]).toLowerCase();
}
let qe;
const wr = new Uint8Array(16);
function vr() {
  if (!qe) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    qe = crypto.getRandomValues.bind(crypto);
  }
  return qe(wr);
}
const xr = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), kt = { randomUUID: xr };
function Pr(e, t, n) {
  if (kt.randomUUID && !t && !e)
    return kt.randomUUID();
  e = e || {};
  const r = e.random || (e.rng || vr)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, mr(r);
}
const se = "__OSRA__", Sr = "__OSRA_DEFAULT_KEY__", re = "__OSRA_PROXY__", zn = (e) => !!(globalThis.SharedArrayBuffer && e instanceof globalThis.SharedArrayBuffer), Bn = (e) => globalThis.ArrayBuffer && e instanceof globalThis.ArrayBuffer || globalThis.MessagePort && e instanceof globalThis.MessagePort || globalThis.ReadableStream && e instanceof globalThis.ReadableStream || globalThis.WritableStream && e instanceof globalThis.WritableStream || globalThis.TransformStream && e instanceof globalThis.TransformStream ? !0 : !!(globalThis.ImageBitmap && e instanceof globalThis.ImageBitmap), Ce = (e) => {
  const t = [], n = (r) => zn(r) ? void 0 : Bn(r) ? t.push(r) : Array.isArray(r) ? r.map(n) : r && typeof r == "object" ? Object.values(r).map(n) : void 0;
  return n(e), t;
}, Er = (e, t) => {
  const n = "portId" in e ? e.portId : void 0, r = "port" in e ? e.port : n ? t.addIncomingProxiedMessagePort(n) : void 0;
  if (!r) throw new Error("No ports received for proxied function");
  const o = (...a) => new Promise((c, u) => {
    const { port1: h, port2: p } = new MessageChannel(), b = X([p, a], t), y = Ce(b), x = (m) => {
      const w = De(m.data, t);
      if (!(w instanceof Promise)) throw new Error("Proxied function did not return a promise");
      w.then(c).catch(u).finally(() => h.close());
    };
    h.addEventListener("message", x, { once: !0 }), h.start(), r.postMessage(b, { transfer: y });
  });
  return n && t.finalizationRegistry.register(o, Number(n.split("/")[1])), o;
}, jr = (e, t) => {
  const n = t.envCheck.supportsPorts && "port" in e ? e.port : "portId" in e ? t.addIncomingProxiedMessagePort(e.portId) : void 0;
  if (!n) throw new Error("No ports received for proxied message port");
  return n;
}, Mr = (e, t) => new Error(e.message, { cause: e.stack }), Or = (e, t) => new Promise((n, r) => {
  const o = "port" in e ? e.port : "portId" in e ? t.addIncomingProxiedMessagePort(e.portId) : void 0;
  if (!o) throw new Error("No ports received for proxied promise");
  const a = async (c) => {
    const u = await De(c.data, t);
    u instanceof Error ? r(u) : n(u), o.close();
  };
  o.addEventListener("message", a, { once: !0 }), o.start();
}), De = (e, t) => xe(
  e,
  (n) => !!(n && typeof n == "object" && re in n && n[re]),
  (n) => {
    if (n.type === "function")
      return Er(n, t);
    if (n.type === "error")
      return Mr(n);
    if (n.type === "messagePort")
      return jr(n, t);
    if (n.type === "promise")
      return Or(n, t);
    throw new Error(`Unknown incoming proxied type: ${e}`);
  }
), Nr = (e, t) => ({
  [re]: !0,
  type: "error",
  message: e.message,
  stack: e.stack
}), Ar = (e, t) => ({
  [re]: !0,
  type: "messagePort",
  ...t.envCheck.supportsPorts ? { port: e } : { portId: t.addOutgoingProxiedMessagePort(e) }
}), Tr = (e, t) => {
  const { port1: n, port2: r } = new MessageChannel(), o = (a) => {
    const c = X(a, t), u = Ce(c);
    n.postMessage(c, { transfer: u }), n.close();
  };
  return e.then(o).catch(o), {
    [re]: !0,
    type: "promise",
    port: X(r, t)
  };
}, Ir = (e, t) => {
  const { port1: n, port2: r } = new MessageChannel();
  return n.addEventListener("message", async (o) => {
    const [a, c] = De(o.data, t), u = (async () => e(...c))(), h = X(u, t), p = Ce(h);
    a.postMessage(h, { transfer: p }), a.close();
  }), n.start(), {
    [re]: !0,
    type: "function",
    port: X(r, t)
  };
}, X = (e, t) => xe(
  e,
  (n) => typeof n == "function" || n instanceof Error || n instanceof MessagePort || n instanceof Promise,
  (n) => {
    if (typeof n == "function")
      return Ir(n, t);
    if (n instanceof Error)
      return Nr(n);
    if (n instanceof MessagePort)
      return Ar(n, t);
    if (n instanceof Promise)
      return Tr(n, t);
    throw new Error(`Unknown outgoing proxied type: ${n}`);
  }
), xe = (e, t, n) => zn(e) || Bn(e) ? e : t(e) ? n(e) : Array.isArray(e) ? e.map((r) => xe(r, t, n)) : e && typeof e == "object" ? Object.fromEntries(
  Object.entries(e).map(([r, o]) => [
    r,
    xe(o, t, n)
  ])
) : e, Cr = () => {
  let e = 0;
  const t = /* @__PURE__ */ new Set();
  return {
    alloc: () => {
      if (t.size > 0) {
        const n = t.values().next().value;
        if (n === void 0)
          throw new Error("Tried to allocate number from freedUnused but result was undefined");
        return t.delete(n), n;
      }
      return e++, e;
    },
    free: (n) => {
      t.add(n);
    }
  };
}, Dr = ({ numberAllocator: e }) => {
  const t = /* @__PURE__ */ new Map();
  return {
    alloc: (a) => {
      const c = e.alloc();
      return t.set(c, a), c;
    },
    get: (a) => t.get(a),
    free: (a) => {
      t.delete(a), e.free(a);
    }
  };
}, Y = async (e, {
  remote: t,
  local: n,
  key: r = Sr,
  origin: o = "*"
}) => {
  const a = Pr();
  let c;
  const u = new FinalizationRegistry((M) => {
    const d = p.get(M);
    if (!d) throw new Error(`Osra received a port-closed message with an invalid portId "${M}".`);
    d(), p.free(M);
  }), h = Cr(), p = Dr({ numberAllocator: h }), b = /* @__PURE__ */ new Map(), y = (M) => {
    const { port1: d, port2: g } = new MessageChannel();
    return b.set(M, d), g;
  }, x = (M) => {
    const d = p.alloc(() => {
      M.close();
    });
    return M.addEventListener("message", async (g) => {
      T(
        {
          [se]: !0,
          key: r,
          type: "message",
          portId: `${a}/${d}`,
          data: X(g.data, m())
        },
        []
      );
    }), M.addEventListener("close", () => {
      h.free(d), T(
        {
          [se]: !0,
          key: r,
          type: "port-closed",
          portId: `${a}/${d}`
        },
        []
      );
    }), `${a}/${d}`;
  }, m = () => {
    if (!c) throw new Error("Osra context was accessed before the ready message was received.");
    return {
      addIncomingProxiedMessagePort: y,
      addOutgoingProxiedMessagePort: x,
      envCheck: c,
      finalizationRegistry: u
    };
  };
  let w;
  const j = new Promise((M, d) => {
    w = M;
  }), N = () => {
    const M = new ArrayBuffer(1), { port1: d } = new MessageChannel();
    T(
      {
        [se]: !0,
        key: r,
        type: "ready",
        envCheck: { buffer: M, port: d }
      },
      [M, d]
    );
  };
  let B = !1;
  const A = async (M) => {
    if (!M.data || typeof M.data != "object" || !M.data[se] || M.data.key !== r) return;
    const { type: d } = M.data;
    if (d === "ready" && !B) {
      B = !0, c = {
        uuid: a,
        supportsPorts: M.data.envCheck.port instanceof MessagePort,
        jsonOnly: M.data.envCheck.buffer instanceof ArrayBuffer
      }, N();
      const g = X(e, m()), P = Ce(g);
      T(
        {
          [se]: !0,
          key: r,
          type: "init",
          data: g
        },
        P
      );
      return;
    }
    if (!B || !c) throw new Error("Osra received a message before the ready message.");
    if (d === "init") {
      w(
        De(
          M.data.data,
          m()
        )
      );
      return;
    }
    if (d === "message") {
      const { portId: g, data: P } = M.data, I = b.get(g);
      if (!I) throw new Error(`Osra received a message with portId set to "${g}" but no port was found.`);
      I.postMessage(P);
    } else if (d === "port-closed") {
      const { portId: g } = M.data, [P, I] = g.split("/"), q = Number(I);
      if (!q) throw new Error(`Osra received a port-closed message with an invalid portId "${g}".`);
      if (P !== a && P !== c.uuid) throw new Error(`Osra received a port-closed message with an invalid portId's uuid "${g}".`);
      if (P === a) {
        const F = p.get(q);
        if (!F) throw new Error(`Osra received a port-closed message with an invalid portId "${g}".`);
        F();
      } else if (P === c.uuid) {
        const F = b.get(g);
        if (!F) throw new Error(`Osra received a message with portId set to "${g}" but no port was found.`);
        F.close(), b.delete(g);
      }
    }
  }, T = typeof t == "function" ? t : (M, d = []) => t.postMessage(M, { targetOrigin: o, transfer: d });
  return typeof n == "function" ? n(A) : n.addEventListener("message", A), N(), j;
};
qn(gr);
const $r = async () => {
  Y({
    test: async (n, r) => {
      if (n.foo !== 1)
        throw new Error("foo is not 1");
      if (r !== "bar")
        throw new Error("bar is not bar");
      return 1;
    }
  }, { remote: window, local: window });
  const { test: t } = await Y({}, { remote: window, local: window });
  await k(t({ foo: 1 }, "bar")).to.eventually.equal(1), await k(t({ foo: 0 }, "baz")).to.be.rejected;
}, _r = async () => {
  Y({ test: async () => async () => 1 }, { remote: window, local: window });
  const { test: t } = await Y({}, { remote: window, local: window }), n = await t();
  await k(n()).to.eventually.equal(1);
}, qr = async () => {
  Y({ test: async (r) => r() }, { remote: window, local: window });
  const { test: t } = await Y({}, { remote: window, local: window }), n = await t(() => 1);
  await k(n).to.equal(1);
}, zr = async () => {
  Y({ test: async (r) => r() }, { remote: window, local: window });
  const { test: t } = await Y({}, { remote: window, local: window }), n = await t(() => 1);
  await k(n).to.equal(1);
}, Br = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  baseArgsAndResponse: $r,
  callback: _r,
  callbackAsArg: qr,
  polyfilledMessageChannel: zr
}, Symbol.toStringTag, { value: "Module" }));
globalThis.tests = Br;
export {
  Br as default
};
//# sourceMappingURL=test.js.map
