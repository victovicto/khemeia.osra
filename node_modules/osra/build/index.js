const p = [];
for (let e = 0; e < 256; ++e)
  p.push((e + 256).toString(16).slice(1));
function N(e, t = 0) {
  return (p[e[t + 0]] + p[e[t + 1]] + p[e[t + 2]] + p[e[t + 3]] + "-" + p[e[t + 4]] + p[e[t + 5]] + "-" + p[e[t + 6]] + p[e[t + 7]] + "-" + p[e[t + 8]] + p[e[t + 9]] + "-" + p[e[t + 10]] + p[e[t + 11]] + p[e[t + 12]] + p[e[t + 13]] + p[e[t + 14]] + p[e[t + 15]]).toLowerCase();
}
let _;
const D = new Uint8Array(16);
function z() {
  if (!_) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    _ = crypto.getRandomValues.bind(crypto);
  }
  return _(D);
}
const Y = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), j = { randomUUID: Y };
function V(e, t, r) {
  if (j.randomUUID && !t && !e)
    return j.randomUUID();
  e = e || {};
  const o = e.random || (e.rng || z)();
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, N(o);
}
const E = "__OSRA__", G = "__OSRA_DEFAULT_KEY__", w = "__OSRA_PROXY__", x = (e) => !!(globalThis.SharedArrayBuffer && e instanceof globalThis.SharedArrayBuffer), B = (e) => globalThis.ArrayBuffer && e instanceof globalThis.ArrayBuffer || globalThis.MessagePort && e instanceof globalThis.MessagePort || globalThis.ReadableStream && e instanceof globalThis.ReadableStream || globalThis.WritableStream && e instanceof globalThis.WritableStream || globalThis.TransformStream && e instanceof globalThis.TransformStream ? !0 : !!(globalThis.ImageBitmap && e instanceof globalThis.ImageBitmap), M = (e) => {
  const t = [], r = (o) => x(o) ? void 0 : B(o) ? t.push(o) : Array.isArray(o) ? o.map(r) : o && typeof o == "object" ? Object.values(o).map(r) : void 0;
  return r(e), t;
}, K = (e, t) => {
  const r = "portId" in e ? e.portId : void 0, o = "port" in e ? e.port : r ? t.addIncomingProxiedMessagePort(r) : void 0;
  if (!o) throw new Error("No ports received for proxied function");
  const c = (...n) => new Promise((i, f) => {
    const { port1: g, port2: l } = new MessageChannel(), m = y([l, n], t), A = M(m), S = (h) => {
      const b = R(h.data, t);
      if (!(b instanceof Promise)) throw new Error("Proxied function did not return a promise");
      b.then(i).catch(f).finally(() => g.close());
    };
    g.addEventListener("message", S, { once: !0 }), g.start(), o.postMessage(m, { transfer: A });
  });
  return r && t.finalizationRegistry.register(c, Number(r.split("/")[1])), c;
}, W = (e, t) => {
  const r = t.envCheck.supportsPorts && "port" in e ? e.port : "portId" in e ? t.addIncomingProxiedMessagePort(e.portId) : void 0;
  if (!r) throw new Error("No ports received for proxied message port");
  return r;
}, X = (e, t) => new Error(e.message, { cause: e.stack }), H = (e, t) => new Promise((r, o) => {
  const c = "port" in e ? e.port : "portId" in e ? t.addIncomingProxiedMessagePort(e.portId) : void 0;
  if (!c) throw new Error("No ports received for proxied promise");
  const n = async (i) => {
    const f = await R(i.data, t);
    f instanceof Error ? o(f) : r(f), c.close();
  };
  c.addEventListener("message", n, { once: !0 }), c.start();
}), R = (e, t) => O(
  e,
  (r) => !!(r && typeof r == "object" && w in r && r[w]),
  (r) => {
    if (r.type === "function")
      return K(r, t);
    if (r.type === "error")
      return X(r);
    if (r.type === "messagePort")
      return W(r, t);
    if (r.type === "promise")
      return H(r, t);
    throw new Error(`Unknown incoming proxied type: ${e}`);
  }
), q = (e, t) => ({
  [w]: !0,
  type: "error",
  message: e.message,
  stack: e.stack
}), F = (e, t) => ({
  [w]: !0,
  type: "messagePort",
  ...t.envCheck.supportsPorts ? { port: e } : { portId: t.addOutgoingProxiedMessagePort(e) }
}), J = (e, t) => {
  const { port1: r, port2: o } = new MessageChannel(), c = (n) => {
    const i = y(n, t), f = M(i);
    r.postMessage(i, { transfer: f }), r.close();
  };
  return e.then(c).catch(c), {
    [w]: !0,
    type: "promise",
    port: y(o, t)
  };
}, Q = (e, t) => {
  const { port1: r, port2: o } = new MessageChannel();
  return r.addEventListener("message", async (c) => {
    const [n, i] = R(c.data, t), f = (async () => e(...i))(), g = y(f, t), l = M(g);
    n.postMessage(g, { transfer: l }), n.close();
  }), r.start(), {
    [w]: !0,
    type: "function",
    port: y(o, t)
  };
}, y = (e, t) => O(
  e,
  (r) => typeof r == "function" || r instanceof Error || r instanceof MessagePort || r instanceof Promise,
  (r) => {
    if (typeof r == "function")
      return Q(r, t);
    if (r instanceof Error)
      return q(r);
    if (r instanceof MessagePort)
      return F(r, t);
    if (r instanceof Promise)
      return J(r, t);
    throw new Error(`Unknown outgoing proxied type: ${r}`);
  }
), O = (e, t, r) => x(e) || B(e) ? e : t(e) ? r(e) : Array.isArray(e) ? e.map((o) => O(o, t, r)) : e && typeof e == "object" ? Object.fromEntries(
  Object.entries(e).map(([o, c]) => [
    o,
    O(c, t, r)
  ])
) : e, Z = () => {
  let e = 0;
  const t = /* @__PURE__ */ new Set();
  return {
    alloc: () => {
      if (t.size > 0) {
        const r = t.values().next().value;
        if (r === void 0)
          throw new Error("Tried to allocate number from freedUnused but result was undefined");
        return t.delete(r), r;
      }
      return e++, e;
    },
    free: (r) => {
      t.add(r);
    }
  };
}, v = ({ numberAllocator: e }) => {
  const t = /* @__PURE__ */ new Map();
  return {
    alloc: (n) => {
      const i = e.alloc();
      return t.set(i, n), i;
    },
    get: (n) => t.get(n),
    free: (n) => {
      t.delete(n), e.free(n);
    }
  };
}, ee = async (e, {
  remote: t,
  local: r,
  key: o = G,
  origin: c = "*"
}) => {
  const n = V();
  let i;
  const f = new FinalizationRegistry((s) => {
    const a = l.get(s);
    if (!a) throw new Error(`Osra received a port-closed message with an invalid portId "${s}".`);
    a(), l.free(s);
  }), g = Z(), l = v({ numberAllocator: g }), m = /* @__PURE__ */ new Map(), A = (s) => {
    const { port1: a, port2: d } = new MessageChannel();
    return m.set(s, a), d;
  }, S = (s) => {
    const a = l.alloc(() => {
      s.close();
    });
    return s.addEventListener("message", async (d) => {
      T(
        {
          [E]: !0,
          key: o,
          type: "message",
          portId: `${n}/${a}`,
          data: y(d.data, h())
        },
        []
      );
    }), s.addEventListener("close", () => {
      g.free(a), T(
        {
          [E]: !0,
          key: o,
          type: "port-closed",
          portId: `${n}/${a}`
        },
        []
      );
    }), `${n}/${a}`;
  }, h = () => {
    if (!i) throw new Error("Osra context was accessed before the ready message was received.");
    return {
      addIncomingProxiedMessagePort: A,
      addOutgoingProxiedMessagePort: S,
      envCheck: i,
      finalizationRegistry: f
    };
  };
  let b;
  const L = new Promise((s, a) => {
    b = s;
  }), U = () => {
    const s = new ArrayBuffer(1), { port1: a } = new MessageChannel();
    T(
      {
        [E]: !0,
        key: o,
        type: "ready",
        envCheck: { buffer: s, port: a }
      },
      [s, a]
    );
  };
  let C = !1;
  const $ = async (s) => {
    if (!s.data || typeof s.data != "object" || !s.data[E] || s.data.key !== o) return;
    const { type: a } = s.data;
    if (a === "ready" && !C) {
      C = !0, i = {
        uuid: n,
        supportsPorts: s.data.envCheck.port instanceof MessagePort,
        jsonOnly: s.data.envCheck.buffer instanceof ArrayBuffer
      }, U();
      const d = y(e, h()), u = M(d);
      T(
        {
          [E]: !0,
          key: o,
          type: "init",
          data: d
        },
        u
      );
      return;
    }
    if (!C || !i) throw new Error("Osra received a message before the ready message.");
    if (a === "init") {
      b(
        R(
          s.data.data,
          h()
        )
      );
      return;
    }
    if (a === "message") {
      const { portId: d, data: u } = s.data, I = m.get(d);
      if (!I) throw new Error(`Osra received a message with portId set to "${d}" but no port was found.`);
      I.postMessage(u);
    } else if (a === "port-closed") {
      const { portId: d } = s.data, [u, I] = d.split("/"), k = Number(I);
      if (!k) throw new Error(`Osra received a port-closed message with an invalid portId "${d}".`);
      if (u !== n && u !== i.uuid) throw new Error(`Osra received a port-closed message with an invalid portId's uuid "${d}".`);
      if (u === n) {
        const P = l.get(k);
        if (!P) throw new Error(`Osra received a port-closed message with an invalid portId "${d}".`);
        P();
      } else if (u === i.uuid) {
        const P = m.get(d);
        if (!P) throw new Error(`Osra received a message with portId set to "${d}" but no port was found.`);
        P.close(), m.delete(d);
      }
    }
  }, T = typeof t == "function" ? t : (s, a = []) => t.postMessage(s, { targetOrigin: c, transfer: a });
  return typeof r == "function" ? r($) : r.addEventListener("message", $), U(), L;
};
export {
  q as errorToProxiedError,
  ee as expose,
  Q as functionToProxiedFunction,
  M as getTransferableObjects,
  x as isClonable,
  B as isTransferable,
  v as makeAllocator,
  Z as makeNumberAllocator,
  F as messagePortToProxiedMessagePort,
  J as promiseToProxiedPromise,
  X as proxiedErrorToError,
  K as proxiedFunctionToFunction,
  W as proxiedMessagePortToMessagePort,
  H as proxiedPromiseToPromise,
  R as replaceIncomingProxiedTypes,
  y as replaceOutgoingProxiedTypes,
  O as replaceRecursive
};
//# sourceMappingURL=index.js.map
